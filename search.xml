<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于依赖注入(typescript)]]></title>
    <url>%2Fblog%2F20181216%2Fa2214845.html</url>
    <content type="text"><![CDATA[一、概念：依赖注入（DI）、控制反转（IOC）、IOC容器依赖注入（DI）和控制反转（IOC）基本是一个意思，因为说起来谁都离不开谁。简单来说，类A依赖类B，但A不控制B的创建和销毁，仅使用B，那么B的控制权则交给A之外处理，这叫控制反转（IOC）。由于A依赖于B，因此在A中必然要使用B的instance，我们可以通过A的构造函数将B的实例注入，比如：123456789class B &#123; &#125;class A &#123; constructor(b: B) &#123; console.log(b); &#125;&#125;const b = new B();// 将B的实例注入到a中const a = new A(b); 这个过程叫依赖注入（DI）。 那么什么是IOC Container（容器）？在刚刚的例子中，将B的实例注入到A的构造函数中的这个过程是我们手动操作的，比较麻烦，特别是当类的关系变多变复杂时，这种方式显得很难维护。因此IOC容器就是为了解决这样的问题，IOC容器负责管理对象的生命周期、依赖关系等，实现对象的依赖查找以及依赖注入。 比如Java的Spring以及前端@Angular框架的依赖注入器（DI）就是属于IOC容器。 接下来我将通过代码的形式对比使用依赖注入相比非依赖注入的好处体现在哪。 二、非依赖注入代码我们先来看一段传统的实现代码（非DI）car.ts12345678910111213141516171819202122// 引擎 export class Engine &#123; public cylinders = '引擎发动机1';&#125;// 轮胎export class Tires &#123; public make = '品牌';&#125;export class Car &#123; public engine: Engine; public tires: Tires; public description = 'No DI'; constructor() &#123; this.engine = new Engine(); this.tires = new Tires(); &#125; // Method using the engine and tires drive() &#123; return `$&#123;this.description&#125; car with ` + `$&#123;this.engine.cylinders&#125; cylinders and $&#123;this.tires.make&#125; tires.`; &#125;&#125; 在以上代码中，Car类没有通过第三方容器而是亲自创建了一个引擎（engine）和一些轮胎（tires），这样的代码耦合度比较高，这样会存在以下问题： 问题1：如果有一天对引擎进行升级，代码如下：1234567// 引擎 export class Engine &#123; public cylinders = ''; constructor(_cylinders:string) &#123; this.cylinders = _cylinders; &#125;&#125; 在创建引擎的时候需要传入一个参数，那么这时候就需要修改Car类里的new Engine(parameter)，这样就导致Car类被破坏了，这里请思考一个问题：要怎么做才能使引擎升级的时候不需要修改Car类呢？（答案：DI） 问题2：如果想在Car上使用不同品牌的轮胎，代码如下：1234567891011121314151617// 轮胎export class Tires &#123; public make = '品牌';&#125;export class Tires1 extends Tires &#123; public make = '品牌1';&#125;export class Tires2 extends Tires &#123; public make = '品牌2';&#125;export class Car &#123; //。。。。。。其他代码省略。。。。。。。 public tires: Tires; constructor() &#123; this.tires = new Tires1(); &#125;&#125; 此时又得重新修改Car的代码，这里请思考一个问题：要怎么做才能使Car更换其他不同品牌的轮胎的时候不需要修改Car类呢？（答案：DI） 问题3：如何实现数据共享，比如说车联网，建立了一个Service数据中心，不同的Car通过Service实现数据通信以及数据共享，如果是通过在Car里new Service的方式，是无法实现数据共享和通信的，因为不同Car里的Service不是同一个实例。 这里请思考一个问题：如何实现不同Car的数据通信和共享呢？ 问题4：测试比较难，根本无法测试。 在示例代码中，Car类依赖于Engine类和Tires类，而Engine和Tires又可能各自依赖于其他的类，而其他的类又可能有各自更多的依赖，在这样层层的依赖关系中，由于不能控制Car背后的隐藏依赖，要进行测试是比较难的，或者应该说，这样的代码是根本无法进行测试的。比如说想同时测试不同品牌的轮子的car的性能，因为car里头的new已经写死了，因此无法做到。比如说想同时测试不同参数的引擎的car的性能，因为car里头的new已经写死了，因此无法做到。除非是每次只测试一种情况，下面拿测试不同品牌的轮子来举例：先测试品牌1的轮子：car.ts123456789101112131415161718192021export class Tires &#123; public make = '品牌';&#125;export class Tires1 extends Tires &#123; public make = '品牌1';&#125;export class Tires2 extends Tires &#123; public make = '品牌2';&#125;export class Car &#123; public tires: Tires; public description = 'No DI'; constructor() &#123; // new 一个品牌1的轮子 this.tires = new Tires1(); &#125; // Method using the engine and tires drive() &#123; return `$&#123;this.description&#125; car with ` + ` $&#123;this.tires.make&#125; tires.`; &#125;&#125; 测试程序car.spec.ts 12345678import &#123; Car &#125; from './car.ts';describe('Car类单元测试', function () &#123; it('测试品牌1轮子的Car的驾驶性能', function () &#123; const car = new Car(); car.drive().should.equal('No DI car with 品牌1 tires.'); &#125;)&#125;) 以上代码对轮子品牌1进行测试，输出轮子品牌1的car的驾驶性能。接着对轮子品牌2进行测试：修改Car类,将this.tires = new Tires1();修改为this.tires = new Tires2();此时输出轮子品牌2的car的驾驶性能。 这样的测试效率是很低的，因为每次只能手动的测试一种情况，如果再加上引擎的测试，那多种混合情况就更多了，根本就不能做到自动测试，所谓的自动测试，是一次性将所有的情况都写到一个单元测试里，一次运行，所有情况都会被测试到，当测试通过了，那么就说明代码达到了预期。 针对以上问题，我们来看看使用DI的好处。 三、使用依赖注入（DI）接下来将演示使用DI来解决以上的4个问题。先看使用DI实现的car.ts代码：car.ts12345678910111213141516171819202122export class Engine &#123; public cylinders = '引擎发动机1';&#125;export class Tires &#123; public make = '品牌';&#125;export class Tires1 extends Tires &#123; public make = '品牌1';&#125;export class Tires2 extends Tires &#123; public make = '品牌2';&#125;export class Car &#123; public description = 'DI'; // 通过构造函数注入Engine和Tires constructor(public engine: Engine, public tires: Tires) &#123;&#125; // Method using the engine and tires drive() &#123; return `$&#123;this.description&#125; car with ` + `$&#123;this.engine.cylinders&#125; cylinders and $&#123;this.tires.make&#125; tires.`; &#125;&#125; 在以上代码中，通过往构造函数中传入engine和tires来创建Car，Car类不再亲自创建engine和tires，而是消费它们，此时最大的好处就是engine和tires与Car解除了强耦的关系。在new Car的时候，可以传入任何类型的Engine和Tires，即 let car = new Car(new Engine(),new Tires()); 解决问题1：如果有一天对引擎进行升级，代码如下：123456export class Engine &#123; public cylinders = ''; constructor(_cylinders:string) &#123; this.cylinders = _cylinders; &#125;&#125; 在创建引擎的时候需要传入一个参数，这时候不需要修改Car类，只需要修改主程序即可： 主程序代码： 1234main()&#123; const car = new Car(new Engine('引擎启动机2'), new Tires1()); car.drive();&#125; 解决问题2：如果想在Car上使用不同品牌的轮胎，代码如下： 12345678910111213export class Tires &#123; public make = '品牌';&#125;export class Tire1 extends Tires &#123; public make = '品牌1';&#125;export class Tire2 extends Tires &#123; public make = '品牌2';&#125;export class Car &#123; //。。。。。。其他代码省略。。。。。。。 constructor(public engine: Engine, public tires: Tires) &#123;&#125; &#125; 此时不需要修改Car类，只需要修改主程序即可：主程序代码：12345main()&#123; // 使用品牌2的轮胎 const car = new Car(new Engine('引擎启动机2'), new Tires2()); car.drive();&#125; 解决问题3：如何实现数据共享，比如说车联网，建立一个Service数据中心（就像angular的Service层，可以给多个component共享），不同的Car通过Service实现数据通信以及数据共享。代码如下：Service.ts1234567891011export class Service &#123; public data = ''; // 向Service存数据 setData(_data: string) &#123; this.data = _data; &#125; // 从Service中取数据 getData() &#123; return this.data; &#125;&#125; car.ts1234567891011export class Car &#123; constructor(public service: Service) &#123; &#125; // 向Service存数据 setDataToService(_data: string) &#123; this.service.setData(_data); &#125; // 从Service中取数据 getDataFromService() &#123; return this.service.getData(); &#125;&#125; 此时主程序如下：主程序代码：12345678910main()&#123; // 创建一个共享服务中心Service const shareService = new Service(); const car1 = new Car(shareService); const car2 = new Car(shareService); // car1向服务中心存数据 car1.setDataToService('this data is from car1.'); // car2从服务中心取数据 car2.getDataFromService();&#125; 解决问题4：测试用例 在示例代码中，Car类依赖于Engine类和Tires类，而Engine和Tires又可能各自依赖于其他的类，而其他的类又可能有各自的依赖，在这样层层的依赖关系中，使用DI的代码测试是比较简单的。测试程序如下：测试程序 car.spec.ts 1234567891011121314151617181920212223242526import &#123; Car,Engine,Tires1, Tires2&#125; from './car.ts';// 测试程序入口describe('Car类单元测试', function () &#123; const engine1 = new Engine('引擎发动机1'); const engine2 = new Engine('引擎发动机2'); const tires1 = new Tires1(); const tires2 = new Tires2(); it('测试引擎1 轮胎品牌1', function () &#123; const car = new Car(engine1, tires1); car.drive().should.equal('DI car with 引擎发动机1 cylinders and 品牌1 tires.'); &#125;); it('测试引擎1 轮胎品牌2', function () &#123; const car = new Car(engine1, tires2); car.drive().should.equal('DI car with 引擎发动机1 cylinders and 品牌2 tires.'); &#125;); it('测试引擎2 轮胎品牌1', function () &#123; const car = new Car(engine2, tires1); car.drive().should.equal('DI car with 引擎发动机2 cylinders and 品牌1 tires.'); &#125;); it('测试引擎2 轮胎品牌2', function () &#123; const car = new Car(engine2, tires2); car.drive().should.equal('DI car with 引擎发动机2 cylinders and 品牌2 tires.'); &#125;); &#125;) 此时觉得很棒有木有，自动测试的思想就是这样的，将所有的情况的代码都配置好，一次运行，所有的情况都可以测试到。 至此，如果看懂以上的话，DI的思想以及为什么要用DI就应该可以理解了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何解决前端跨域问题]]></title>
    <url>%2Fblog%2F20181209%2F8d45a80b.html</url>
    <content type="text"><![CDATA[为什么会跨域?​ 跨域主要是浏览器限制的，浏览器要求请求的url地址与当前的页面的url地址处于域名、端口号、协议一致，如果出现其中的一项不一致，则跨域。 ​ 因为我现在做的项目是前后端分离的，所以会出现这个问题。 ​ 先说一下我的服务器环境：centos7 + nginx，假设我的前端项目部署在服务器的http://100.100.100.100:80上，而后端项目部署在http://100.100.100.100:8080上，那么此时前端项目（80端口）请求服务器接口（8080端口）时，浏览器就会提示跨域，导致请求受限制。 解决方式： 方法一：通过设置后端的cors允许跨域这种方式比较简单,需要配合后端实现,通过在后端设置cors允许跨域，可以指定ip,也可以用”*“允许全部.以下是在koa2中允许跨域代码（不同的服务器框架或语言的跨域配置类似） 12345678910app.use(cors(&#123; origin: function (ctx) &#123; return &quot;*&quot;; &#125;, exposeHeaders: [&apos;WWW-Authenticate&apos;, &apos;Server-Authorization&apos;], maxAge: 5, credentials: true, allowMethods: [&apos;GET&apos;, &apos;POST&apos;, &apos;DELETE&apos;, &apos;PUT&apos;], allowHeaders: [&apos;Content-Type&apos;, &apos;Authorization&apos;, &apos;Accept&apos;, &apos;accesstoken&apos;],&#125;)) 方法二：通过JsonPJsonP的原理大概就是，利用浏览器对script加载完自动执行的特新来实现的。 比如前端有一段代码： 12345&lt;script&gt; function handle(data)&#123; console.log(data); &#125;&lt;/script&gt; 假设服务器接口名为 http://100.100.100.100/getData该接口返回一个文件，文件内容为： 1handle(&apos;数据。数据。数据。&apos;); 那么请看以下前端代码： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script&gt; function handle(data)&#123; console.log(data); &#125; &lt;/script&gt; &lt;script&gt; var url = &quot;http://100.100.100.100/getData&quot;; var script = document.createElement(&apos;script&apos;); script.setAttribute(&apos;src&apos;, url); document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; ​ 当第二个script里的代码执行完之后，第一个script里的handle就会被调用，此时输出&#39;数据。数据。数据。&#39;。 ​ 采用JsonP的过程比较繁琐，需要客户端和服务器端两端的同时配合，因此需要特别处理的接口可以使用，一般传统的后台接口不会采用这种方式进行跨域。 方法三：通过nginx反向代理采用nginx反向代理能很好的实现跨域，目前我的项目就是采用的这种方式。 ​ 先做以下假设： ​ 我的服务器域名为 www.simple.com ip为：100.100.100.100 ​ 前端项目部署在100.100.100.100:80 ​ 后端项目部署在100.100.100.100:8080 ​ 那么为了实现跨域，我可以这么配置我的nginx。 ​ https://www.simple.com =&gt; 100.100.100.100:80 ​ https://www.simple.com/api =&gt; 100.100.100.100:8080 ​ 当前端项目要请求接口的时候，可以通过https://www.simple.com/api进行请求，完美跨域。]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于js正则表达式的贪婪和懒惰模式]]></title>
    <url>%2Fblog%2F20181130%2F3ba3fd82.html</url>
    <content type="text"><![CDATA[1、量词 正则表达式的量词有：* + ? {} * : 匹配0次到多次 + : 匹配1次到多次 ? : 匹配0次或1次 {n,m} : 匹配至少n次，最多m次 {n} : 匹配n次 {0,} : 等价于* {1,} : 等价于+ {0,1} : 等价于? 量词默认是贪婪模式，当在量词后面加上一个问号?时，就变成了懒惰模式。 2、贪婪模式 使用量词(* + ? {})时，默认为贪婪模式。 贪婪模式尝试匹配最多字符，具体怎么做呢？ 首先尝试匹配整个字符串，如果匹配不成功，就去掉最后一个字符，并再次尝试匹配，直到匹配成功或者字符串为空为止。 举个例子： 1234demo1.jslet str1 = 'xxx123xxxxxxxxxx123xxx';let regex1 = /.*123/; console.log(regex1.exec(str1)[0]); 输出结果：’xxx123xxxxxxxxxx123’ 分析demo1代码,由于使用量词，因此默认为贪婪模式，会尝试匹配最多字符，即匹配全部字符 第1次尝试：’xxx123xxxxxxxxxx123xxx’ 与 /.123/ 不匹配 第2次尝试：’xxx123xxxxxxxxxx123xx’ 与 /.123/ 不匹配 第3次尝试：’xxx123xxxxxxxxxx123x’ 与 /.123/ 不匹配 第4次尝试：’xxx123xxxxxxxxxx123’ 与 /.*123/ 匹配 因此匹配结果为：’xxx123xxxxxxxxxx123’ 3、懒惰模式 在量词(* + ? {})后直接加上?时，即为懒惰模式。 懒惰模式尝试匹配最少字符，具体怎么做呢？ 首先尝试匹配空字符串，如果匹配不成功，就多读取一个字符，并再次尝试匹配，直到匹配成功或者整个字符串读取完为止。 看下面例子： 1234demo2.jslet str2 = "xxx123xxxxxxxxxx123xxx";let regex2 = /3*?/;console.log(regex2.exec(str2)[0]); 输出结果：’’ 分析demo2代码,由于在量词后加入了?，因此采用懒惰模式，会尝试匹配最少字符。 第1次尝试：’’ 与 /3?/ 匹配 因此匹配结果为：’’]]></content>
  </entry>
  <entry>
    <title><![CDATA[基于js对观察订阅者模式的一些体会和应用场景]]></title>
    <url>%2Fblog%2F20181124%2F19bf8033.html</url>
    <content type="text"><![CDATA[1、自己实现一个简单版的rxjs：SimpleObservable1234567891011121314151617181920212223242526SimpleObservable.tsclass SimpleObservable &#123; private observer: Array&lt;Function&gt;; constructor() &#123; this.observer = []; &#125; subscribe(_observer: Function) &#123; this.observer.push(_observer); let _index = this.observer.length - 1; let that = this; return &#123; _index: _index, unsubscribe: function () &#123; console.log("before:unsubscribe:", that.observer); that.observer.splice(this._index, 1); console.log("after :unsubscribe:", that.observer); &#125; &#125;; &#125; next(_data: any) &#123; for (let i = 0, len = this.observer.length; i &lt; len; i++) &#123; this.observer[i](_data); &#125; &#125;&#125;export default SimpleObservable; 2、实现监听场景：在项目中，不同页面的header样式一样，只有title文字不一样，比如page1显示的titile是’page1’，而page2显示的titile是’page2’,于是我把header做成了一个组件，而每个页面也是一个组件，因此通过SimpleObservable就可以实现组件与组件间的间接单向通信，即观察者（observer）监听被观察者（observable），被观察者触发观察者。 （备注：以下用ts语法，可以通过tsc编译生成对应js，再运行） 大致代码如下： demo1 1234567891011121314151617demo1.tsimport SimpleObservable from './SimpleObservable';let subscriptions=[];let headerTitleObservable = new SimpleObservable();let headerTitle_subscriptsion = headerTitleObservable .subscribe(_title =&gt; &#123; console.log(`the header title is change to$&#123;_title &#125;`); &#125;);subscriptions.push(headerTitle_subscriptsion );// 触发this.headerTitleObservable.next('page1');// 在组件生命周期结束时，清除所有observerssubscriptions.forEach(subscription =&gt; &#123; subscription.unsubscribe(); &#125;); 2、解除两个类的强耦合状态使用观察订阅者模式，有时候能解除两个类的强耦合状态，比如，在我的项目中，我写了一个http拦截器httpInterceptor,用来过滤每一次http请求和响应，比如统一加access_token header，统一出错处理啊等等，我的httpInterceptor其中的一个功能，就是从服务器返回的响应头中检测登录状态是否已经失效或access_token是否已经过期，当检测到登录失效时，要在页面中弹出一个登录modal框（loginModalComponent），提醒用户重新登录。大致的代码如下： (备注：以下采用ts语法，为了使理解起来更加容易，没有使用ts的依赖注入等特性) 未使用观察者模式： demo2 12345678910111213141516171819202122232425262728293031demo2.ts/** * 这里模拟了一个登录modal组件 */class LoginModalComponent &#123; constructor() &#123; &#125; open() &#123; console.log('##检测到access_token已经过期，打开login模态框##'); console.log('请输入账号和密码,点击登录'); &#125;&#125;/** * 这里模拟了一个http拦截器 */class HttpInterceptor &#123; loginModalComponent: LoginModalComponent = new LoginModalComponent();; constructor() &#123; &#125; handleHttpRes() &#123; if (this.checkLoginInvalid) &#123; this.loginModalComponent.open(); &#125; &#125; // 检查登录是否失效 checkLoginInvalid() &#123; return true; &#125;&#125;let httpInterceptor = new HttpInterceptor();httpInterceptor.handleHttpRes(); 以上示例代码是未使用观察者模式的情况下，需要在HttpInterceptor里new LoginModalComponent,从而导致HttpInterceptor和LoginModalComponent处于强耦合的状态，但是这样不符合HttpInterceptor拦截器的思想，因为HttpInterceptor拦截器是不应该和组件相关的东西进行耦合的，因此，采用观察者模式进行改进. 代码如下： demo3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101demo3.tsclass SimpleObservable &#123; private observer: Array&lt;Function&gt;; constructor() &#123; this.observer = []; &#125; subscribe(_observer: Function) &#123; this.observer.push(_observer); let _index = this.observer.length - 1; let that = this; return &#123; _index: _index, unsubscribe: function () &#123; console.log("before:unsubscribe:", that.observer); that.observer.splice(this._index, 1); console.log("after :unsubscribe:", that.observer); &#125; &#125;; &#125; next(_data: any) &#123; for (let i = 0, len = this.observer.length; i &lt; len; i++) &#123; this.observer[i](_data); &#125; &#125;&#125;/** * 这里模拟了一个登录modal组件 */class LoginModalComponent &#123; constructor() &#123; &#125; open() &#123; console.log('##检测到access_token已经过期，打开login模态框##'); console.log('请输入账号和密码,点击登录'); &#125;&#125;/** * 通过一个service来作为中间者，从而解除HttpInterceptor和LoginModalComponent强耦合状态。 */class HttpStatusService &#123; login_invalid_observable = new SimpleObservable(); constructor() &#123; &#125; getLoginInvalidObservable() &#123; return this.login_invalid_observable; &#125; triggerLoginInvalidObservable() &#123; this.login_invalid_observable.next('access_token is invalid.') &#125;&#125;/** * 创建一个HttpStatusService的实例，全局可用，实际的做法是采用ts的依赖注入 */let httpStatusService: HttpStatusService = new HttpStatusService();/** * 这里模拟了一个http拦截器 */class HttpInterceptor &#123; constructor() &#123; &#125; handleHttpRes() &#123; if (this.checkLoginInvalid) &#123; httpStatusService.triggerLoginInvalidObservable(); &#125; &#125; // 模拟一个登录失败的状态，实际的情况是，拦截到http请求的服务器响应信息 checkLoginInvalid() &#123; return true; &#125;&#125;/** * AppComponent,一个页面跟组件 */class AppComponent &#123; loginModalComponent: LoginModalComponent = new LoginModalComponent(); subscriptions: Array&lt;any&gt; = []; constructor() &#123; this.init(); &#125; init() &#123; let subscription1 = httpStatusService.getLoginInvalidObservable().subscribe((err_msg) =&gt; &#123; this.loginModalComponent.open(); &#125;); this.subscriptions.push(subscription1); &#125; onDestroy() &#123; this.subscriptions.forEach(subscription =&gt; &#123; subscription.unsubscribe(); &#125;); &#125;&#125;let appComponent = new AppComponent();/** * 此时appComponent已经在监听httpStatusService里的login_invalid_observable */let httpInterceptor = new HttpInterceptor();httpInterceptor.handleHttpRes();appComponent.onDestroy();]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于js（es5）如何优雅地创建对象]]></title>
    <url>%2Fblog%2F20181115%2F7df91c4c.html</url>
    <content type="text"><![CDATA[一、前颜（yan）对象（Object Oriented，OO）对于基于类的语言来说是再普通不过的一个概念 了，比如C++，Java等等。而在es5（以下js指es5）中，由于没有类的概念，因此它的对象与其他基于类的语言的对象是不同的。因此在js中，关于对象的创建方法也有所不一样。本文介绍各种创建js对象的方法，以及优缺点。 二、通过Object创建对象123456var cat = new Object();cat.name = 'kiki1';cat.age = 1;cat.speak = function () &#123; console.log('Hello I am ', this.name);&#125; 缺点：当需要创建多个相似对象时，会产生大量的重复代码，比如这时候我想再创建一个cat2，这时就得重复一遍以上代码。123456var cat2 = new Object();cat2.name = 'kiki2';cat2.age = 2;cat2.speak = function () &#123; console.log('Hello I am ', this.name);&#125; 三、通过对象字面量语法对象1234567var cat = &#123; name: 'kiki1', age: 1, speak: function () &#123; console.log('Hello I am ', this.name); &#125;&#125; 特点：通过此方法来创建对象相比Object创建对象代码简洁了很多缺点：与通过Object创建对象的缺点一致 为了解决以上问题，以下模式来了。 四、通过工厂模式创建对象123456789101112131415function createCat(name, age) &#123; var o = new Object(); o.name = name; o.age = age; o.speak = function () &#123; console.log('Hello I am ', this.name); &#125; return o;&#125;var cat1=createCat('kiki1',1);var cat2=createCat('kiki2',2);cat1.speak(); //Hello I am kiki1cat2.speak(); //Hello I am kiki2 特点：通过工厂模式创建对象，可以解决创建多个相似对象的问题。缺点：无法识别对象，即无法知道一个对象的类型。 五、通过构造函数模式创建对象通过构造函数模式创建对象，能够很好的解决工厂模式创建对象的问题。 1234567891011121314151617181920function Cat(name, age) &#123; this.name = name; this.age = age; this.speak = function () &#123; console.log('Hello I am ', this.name); &#125;&#125;let cat1 = new Cat('kiki1', 1);let cat2 = new Cat('kiki2', 2);cat1.speak(); //Hello I am kiki1cat2.speak(); //Hello I am kiki2// 检测对象类型console.log(cat1 instanceof Cat); // trueconsole.log(cat2 instanceof Cat); // true// 不同实例上的同名函数是不相等console.log(cat1.speak == cat2.speak); // false 特点：1、通过new Cat来创建实例2、可以通过instanceof来检测对象类型缺点：使用构造函数的缺点在于，每个方法都会在实例上重新创建一遍，所以不同实例上的同名函数是不相等的,即无法共享方法。比如上面的例子中的cat1.speak和cat2.speak是不相等的。 为了解决此缺点，请看原型模式。 六、原型模式123456789101112131415161718function Cat() &#123; &#125;Cat.prototype.name = 'kiki1';Cat.prototype.age = 1;Cat.prototype.speak = function () &#123; console.log('Hello I am ', this.name);&#125;Cat.prototype.data = [1, 2];let cat1 = new Cat();let cat2 = new Cat();console.log(cat1.speak == cat2.speak); // true// 引用类型属性，不同实例之间互相影响console.log(cat2.data); // [1,2]cat1.data.push(3);console.log(cat1.data); // [1,2,3]console.log(cat2.data); // [1,2,3] 特点：共享方法，比如上面的例子中，cat1.speak和cat2.speak是相等的。缺点：由于引用类型的属性也是共享的，因此不同实例之间会互相影响 六、组合模式组合模式：即构造函数模式+原型模式。采用组合模式可以解决构造函数模式和原型模式的问题，又拥有构造函数和原型模式的特点，集两种模式之长。通过构造函数模式定义实例属性，通过原型模式定义共享方法和共享属性。 12345678910111213141516function Cat(name, age, data) &#123; this.name = name; this.age = age; this.data = data;&#125;Cat.prototype.speak = function () &#123; console.log('Hello I am ', this.name);&#125;let cat1 = new Cat('kiki1', 1, [1, 2, 3]);let cat2 = new Cat('kiki2', 2, [3, 4, 5]);console.log(cat1.speak == cat2.speak); // trueconsole.log(cat1.data); // [1,2,3]console.log(cat2.data); // [3,4,5] 综上对比，组合模式是最优雅的创建对象的方式。]]></content>
  </entry>
  <entry>
    <title><![CDATA[基于mocha、should.js、karma、travis ci实现前端自动化持续测试]]></title>
    <url>%2Fblog%2F20181108%2F16dc22b.html</url>
    <content type="text"><![CDATA[前颜（yan）首先你觉得测试重要吗？为什么重要？ 这里举个例子，假如你写了一个逻辑稍微比较复杂的函数，这个函数被很多地方调用到，那么当过了N多天之后，你可能快要忘记这里面的逻辑了，此时你可能出于某种原因需要为这个函数增加一些功能，修改这个函数的代码，那么你要怎么做才能做到修改后不影响其他的调用者呢，或者说，你要怎么做，才能快速的知道哪些地方受影响，哪些地方不受影响呢？ 很明显，答案就是：跑测试用例 对于单元测试，我能想到的好处有： 改进代码设计，提高代码质量：单元测试会强制你对代码进行合理的设计，解耦，写出可测试的代码 允许重构，你可以放心的对代码进行修改，因为你有测试用例来确保你的代码能够按符合预期要求 快速定位bug 既然单元测试这么重要，那么就应该好好重视起来。 前端测试框架和库目前前端测试框架和库主要有assert、should.js、expect、chai、mocha、jasmine、karma以及travis ci等等。 其中assert、should.js、expect、chai属于断言库，实现对js代码进行断言测试。 ​而mocha、jasmine属于测试框架，测试框架通过使用断言库对js代码进行测试，生成测试报告，除此之外，测试框架还提供了各种生命周期。 ​karma则属于测试工具，能够模拟各种环境来运行你的测试代码，比如Chrome，Firefox，mobile等等。 ​重点要介绍的是travis ci，是一个远程免费的持续集成（CI）服务，你可以通过配置绑定你github上的项目，并且配置运行环境，实现只要github上有代码更新，travis就会自动运行构建和测试，并反馈运行结果。 ​下面对不同断言库进行简单的介绍： ​断言库（主要实现对代码进行测试） assert ：TDD风格断言，是nodejs的一个断言测试模块，提供的api不是很多 1assert.equal(foo, 'foo'); should.jd：BDD风格断言库，should相对于assert有比较丰富的api，并且其语法非常的语义化 123foo.should.be(); bar.should.have();foo.should.bot.be(); expect：BDD风格断言，语法和should.js类似 1234expect(foo).to.be();expect(foo).to.eql();expect(foo).to.be.a();expect(foo).not.to.be.an(); chai：支持BDD/TDD双模式，同时支持should/expect/assert三种风格的断言库，还有强大的插件机制 1234567891011shouldchai.should();foo.should.be.a('string');expectvar expect = chai.expect;expect(foo).to.be.a('string');assertvar assert = chai.assert;assert.typeOf(foo, 'string'); 接下来，我将使用mocha、should.js、karma、travis ci实现几个前端js自动化持续测试的demo。大家可以克隆相应的代码下来对应着看，由于篇幅有限，下面只讲关键点。 demo1(mocha+should.js)特点：直接使用mocha和should.js来跑测试用例。 代码地址：https://github.com/SimpleCodeCX/myCode/tree/master/test/demo1 关键点说明： 1 下载相关依赖（mocha和should.js） 12npm instal -g mocha （全局）npm install --save-dev should 2 添加主功能（待测试）代码 12345#src/main.jsfunction add(x, y) &#123; return x + y;&#125;module.exports = add; 3 添加测试用例 12345678#test/test.jsvar add = require('../src/main')describe('add', function () &#123; it('8 + 8 = 16', function () &#123; add(8, 8).should.equal(16); &#125;)&#125;) 4 配置mocha.opts 12#test/mocha.opts--require should 关于mocha.opts的更多配置（代替命令行参数）：https://mochajs.org/#mochaopts 5 运行 1mocha 输出测试结果 123456&gt;mochaadd √ 8 + 8 = 16 1 passing (10ms) demo2(mocha+should.js+karma)特点： 通过karma调用mocha测试框架来进行代码测试 优点在于karma能模拟浏览器比如Chrome、Firefox来运行测试代码 代码地址：https://github.com/SimpleCodeCX/myCode/tree/master/test/demo2 关键点说明： 1 下载相关依赖（mocha、should.js和karma） 12345npm install --save-dev mocha（demo1使用的是全局mocha，这里是karma调用mocha）npm install --save-dev shouldnpm install --save-dev karmanpm install --save-dev karma-chrome-launchernpm install --save-dev karma-mocha 2 添加主功能（待测试）代码 12345#src/main.js(注意和demo1的区别)function add(x, y) &#123; return x + y;&#125; 3 添加测试用例 1234567#test/test.js(注意和demo1的区别)describe('add', function () &#123; it('8 + 8 = 16', function () &#123; add(8, 8).should.equal(16); &#125;)&#125;) 4 配置karma（karma.conf.js） 运行 karma init，按提示操作。 12345678910111213141516171819202122232425262728293031Which testing framework do you want to use ?Press tab to list possible options. Enter to move to the next question.&gt; mochaDo you want to use Require.js ?This will add Require.js plugin.Press tab to list possible options. Enter to move to the next question.&gt; noDo you want to capture any browsers automatically ?Press tab to list possible options. Enter empty string to move to the next question.&gt; Chrome&gt;What is the location of your source and test files ?You can use glob patterns, eg. &quot;js/*.js&quot; or &quot;test/**/*Spec.js&quot;.Enter empty string to move to the next question.&gt; test/**/*.js&gt;Should any of the files included by the previous patterns be excluded ?You can use glob patterns, eg. &quot;**/*.swp&quot;.Enter empty string to move to the next question.&gt;Do you want Karma to watch all the files and run the tests on change ?Press tab to list possible options.&gt; yesConfig file generated at &quot;...\demo2\karma.conf.js&quot;. 然后在karma.conf.js中的files添加相关的依赖模块：12345files: [ &apos;node_modules/should/should.js&apos;, &apos;test/**/*.js&apos;, &apos;src/**/*.js&apos; ] 关于karma的更多配置：http://karma-runner.github.io/3.0/config/configuration-file.html 5 运行 1karma start karma会运行chrome浏览器，并且输出测试结果 1234567&gt;karma start08 11 2018 21:01:34.765:WARN [karma]: No captured browser, open http://localhost:9876/08 11 2018 21:01:34.775:INFO [karma]: Karma v1.7.1 server started at http://0.0.0.0:9876/08 11 2018 21:01:34.775:INFO [launcher]: Launching browser Chrome with unlimited concurrency08 11 2018 21:01:34.785:INFO [launcher]: Starting browser Chrome08 11 2018 21:01:37.456:INFO [Chrome 70.0.3538 (Windows 7.0.0)]: Connected on socket h9aSRbkdzZNTgb2dAAAA with id 46125810Chrome 70.0.3538 (Windows 7.0.0): Executed 1 of 1 SUCCESS (0.007 secs / 0.002 secs) demo3(mocha+should.js+karma+travis)代码地址：https://github.com/SimpleCodeCX/myCode/tree/master/test/demo3 1 复制demo2的工程作为demo3 2 在github上创建一个新工程demo3，并关联本地仓库 1git remote add origin git@github.com:SimpleCodeCX/demo3.git 3 使用github账号登录travis官网，同步并激活监听github上的demo3项目 参考文章：http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html 4 配置travis（.travis.yml） 在demo3的根目录下新建.travis.yml文件，并做如下配置：123456789language: node_jsnode_js: - &quot;8&quot;script: karma start --single-runbefore_install: - npm install - export CHROME_BIN=chromium-browser - export DISPLAY=:99.0 - sh -e /etc/init.d/xvfb start 5 提交到远程仓库上 123git add . git commit -m &apos;add travis ci&apos;git push origin master 6 此时可以在travis上查看测试反馈 有关travis的配置文档：https://docs.travis-ci.com/user/languages/javascript-with-nodejs/ 参考文档：https://nodejs.org/api/assert.htmlhttps://github.com/shouldjs/should.jshttps://github.com/Automattic/expect.jshttps://www.chaijs.comhttps://mochajs.orghttps://jasmine.github.iohttp://karma-runner.github.iohttps://docs.travis-ci.com/user/languages/javascript-with-nodejs]]></content>
  </entry>
  <entry>
    <title><![CDATA[基于nodejs的雪碧图制作工具]]></title>
    <url>%2Fblog%2F20181103%2Fd968dc4.html</url>
    <content type="text"><![CDATA[前颜（yan）雪碧图（CSS sprite ），就是把很多小图标合并为一张图片。 在Web开发中，使用雪碧图是优化Web性能的一种方法。 比如你可能遇到过这样的一种场景：在你的页面中，使用到了很多的小图标，然后你的每个小图标都是通过img src来引用的。比如：1&lt;img src='logo.png'&gt; 通过这种方式虽然比较方便，但是存在的一个缺点就是性能问题，即浏览器在解析每个小图标时，都要发起一次http或（https）请求，而这个小图标本身却很小，可能只有十几k甚至几k，那么为每个小图标单独发起http请求，其实有点资源浪费。 为什么会资源浪费呢？ 浏览器在与服务器进行http请求的过程中，需要有一个类似握手通信的过程，然后才是真正的获取数据。 举个例子，在这里我把浏览器发起的http图片请求简单分为两个过程，分别为： 1、浏览器与服务器的通信握手过程，假设耗时X ms（毫秒） 2、真正的数据获取过程，假设耗时 Y ms（毫秒） 那么浏览器发起一次http请求的总耗时为：sum(1)=X+Y ms，由于小图标数据很小，可能只有几k，因此通信过程的耗时X是大于Y的。 而当你在网页中引用了很多小图标时，假设有n个小图标，此时总耗时为sum(n)=nX+nY ms，通过对比sum(1)和sum(n)，你就会发现，上面所说的资源浪费主要是在于通信握手的时间Y。此时，我就会想，如果我一次性取得所有的小图标，那么总耗时就变成了sum(n)=nX+Y ms，这样就能节省(n-1)Y的http握手通信的时间开销，从而优化了web的响应性能。 一、雪碧图抠图（background-position）通过前面的介绍，我们知道，雪碧图的原理就是将页面中使用到的小图标合成为一张总图。这样的话当我们想要使用雪碧图中的某一个小图标，应该通过如何实现呢？ 答案是通过css的background-position，background-position的默认坐标是（0，0），关于background-position的详细使用，大家可以网上搜索一下，资料很多。（这次主要讲雪碧图制作工具） 二、雪碧图制作工具 simple-sprite那么如何合成雪碧图呢？怎样才能更方便的合成雪碧图呢？ 因为懒，我的想法是，每次当我需要合成雪碧图时，我只要经过以下尽量简单的步骤就可以快速合成，并且可以导出各个小图标在雪碧图中的background-position css样式。为此，我用nodejs写了一个雪碧图制作工具：simple-sprite，并打包生成npm包发布至npm官网。 雪碧图制作步骤如下： 1 创建雪碧图生成工程 12mkdir sprite-generatorcd sprite-generator 2 初始化工程1npm init 3 把所有小图标放到imgs中1mkdir imgs &amp;&amp; 把所有的小图标放到imgs中 4 下载 simple-sprite npm包1npm install --save simple-sprite 5 运行生成雪碧图123let sprite = require('simple-sprite');sprite.generateSprite('./imgs'); simple-sprite：https://www.npmjs.com/package/simple-sprite 三、github源码构建工具：rollup github源码：https://github.com/SimpleCodeCX/simple-sprite#readme （如果你点开了我的github源码连接，顺便也帮我点个star哦！哈哈）]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Diffie-Hellman密钥协商算法]]></title>
    <url>%2Fblog%2F20180923%2F4db4f43.html</url>
    <content type="text"><![CDATA[加密算法介绍目前常用的加密算法主要有：哈希算法（比如MD5、SHA族、Hmac），对称加密算法（比如AES），非对称加密算法（RSA），以及Diffie-Hellman密钥协商算法等等，这几种算法都有各自的特点，适合的场景也不一样，这里只做简单的介绍，想详细了解的话，网上资料很多，可以自行查看相关的资料。 各类算法的特点： 哈希算法：正向快速，不可逆性，即加密后是很难解密出明文的。经常用于数据加密和数据校验。 对称加密算法：AES是一种常用的对称加密算法，其特点是加解密都用同一个密钥。 非对称加密算法RSA：RSA算法是一种非对称加密算法，由一个私钥和一个公钥构成的密钥对，通过私钥加密，公钥解密，或者通过公钥加密，私钥解密。其中，公钥可以公开，私钥必须保密。 Diffie-Hellman密钥协商算法：Diffie-Hellman是一种密钥协商算法（简称DH算法），DH算法基于一种数学原理，能够在双方不泄露密钥的情况下协商出一种密钥来。 场景描述在客户端向服务器端发送数据的过程中，如果是比较重要的数据（比如密码，敏感数据等），一般需要先在客户端进行加密后再发送，服务器接收到数据后再进行解密得到原始数据。(反过来服务器返回数据给客户端也是一样的道理) 这里假设客户端和服务器端采用AES（对称加密算法）进行加解密传输的数据，AES加密算法有一个特点就是加解密都用同一个密钥（这里把该密钥称作secretKey），所以双方都通过secretKey进行数据加解密。 因此在客户端向服务器第一次传输数据的时候，客户端需要先向服务器端获取secretKey，并且保存在客户端，而这种直接向服务器获取明文secretKey的过程是很容易被第三者拦截的，也就是说这一过程是不安全的。（哈哈，除非是服务器把secretKey写到纸上，亲手偷偷地递给客户端） 因此呢，客户端向服务器获取secretKey的这一过程，也是需要进行加密的。 那么，服务器需要怎么做才能把secretKey安全的送达客户端呢？ 目前常采用的方法有：RSA 或 Diffie-Hellman 通过RSA安全传输密钥RSA有一个公钥和一个私钥，公钥是允许公开出去的，私钥是保留的。RSA的要点在于用公钥加密的数据需要用私钥解密，用私钥加密的数据，需要用公钥解密。因此，比如这时候客户端把公钥发送给服务器，服务器利用客户端的公钥对secretKey进行加密，那么这份加密后的secretKey数据，就只有客户端的私钥能解开啦。即使第三者拿到了这份数据也解密不了，除非能获取到客户端的私钥。 所以，通过RSA的方式，服务器就能把secretKey安全的传递到客户端的手里啦。（不过，RSA也是有安全漏洞的，被称作中间人攻击，由于篇幅原因，这里就先不讲啦！大家自行百度。） 虽然使用RSA能够安全的传输secretKey密钥，但是麻烦点在于需要生成一对公钥和私钥，并且把公钥发送给对方，而且加解密速度比较慢。所以，介绍第二种：Diffie-Hellman密钥协商算法。 通过DH算法协商密钥严格来说，DH算法其实并不是一种加密算法，因为它本身并不是用于加密的，我的理解是用于双方协商计算，即双方按照某种合约进行计算，从而计算出一种相同的结果。 原理如下： 第一步：初始化 &nbsp;&nbsp;&nbsp;&nbsp;比如现在服务器提供了两个随机公钥数字（允许公开）：pubN=10，modN=3; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端自己生成了一个随机私钥数字（不可公开，服务器也不知道）：cPrivN=2; 服务器端也自己生成了一个随机私钥数字（不可公开，客户端也不知道）：sPrivN=4; 第二步：客户端、服务器端分别基于相同的数学公式进行计算，计算结果称作公钥结果：pubResult 客户端进行数学计算：cPubResult = pubN cPrivN % modN = 10 2 % 3 = 2；（计算结果允许公开） 服务器进行数学计算：sPubResult = pubN sPrivN % modN = 10 4 % 3 = 1；（计算结果允许公开） 客户端和服务器端交换公钥结果，客户端得到sPubResult=1，服务器端得到cPubResult=2。 第三步：协商出一致的密钥数字:keyN（客户端和服务器端得出的结果是一致的） 客户端：cKeyN = sPubResult cPrivN % modN= 1 2 % 3 = 2；服务器：sKeyN = cPubResult sPrivN % modN= 2 4 % 3 = 2； 到目前为止呢，双方都协商出了密钥，并且是一致的，但是呢，有没有见过密钥是number类型的？想必都没有吧，所以需要进行第四步，生成更长的密钥。 第四步：对密钥数字进行hash生成密钥串 123const hash = crypto.createHash('sha256');hash.update(this.keyN.toString());this.secretKey = hash.digest('hex');]]></content>
  </entry>
  <entry>
    <title><![CDATA[基于ionic4、cordova搭建android开发环境]]></title>
    <url>%2Fblog%2F20180827%2Fa09cfe7a.html</url>
    <content type="text"><![CDATA[前颜（yan）最近公司有一个项目需求是利用h5进行跨平台开发，这里所说的跨平台开发指的是：将h5代码利用某种方式或工具环境进行打包，最后生成android的apk以及ios的ipa。本文只讲解android开发环境，等以后有空了再介绍一篇关于ios的。 一、知识讲解本文基于ionic4+cordova构建android应用，首先做一下以下的知识梳理。 1 ionic是一套用于开发混合手机应用的开源h5框架，包含一套适合于mobile application的ui组件库以及相关访问原生设备的native接口等。目前ionic已更新至ionic4，ionic4的特色在于兼容angular6以及rxjs6，有着angular6的特点，因此，angular的开发者可以很容易的切换到ionic4的开发。ionic官方文档：https://beta.ionicframework.com/docs/intro 2 cordova是一套开源的移动应用开发框架。cordova能够利用web应用（如ionic构建的h5应用）构建android工程以及ios工程（今天只讲android工程）。并且可以编译android工程，最后生成android apk。cordova官方文档：https://cordova.apache.org/docs/en/latest/guide/overview/index.html 3 android sdkcordova在编译android工程的时候需要有android sdk等开发环境的支持。如果想对ionic和cordova更加详细的了解，请见官方文档。 接下来，开始搭建开发环境。因此，综上所述，需要搭建的开发环境有：ionic、cordova以及android 开发环境。 我的开发环境如下（仅供参考）：node：v8.11.1npm：5.5.1ionic：4.0.3cordova：8.0.0jdk：1.8.0_45gradle：4.9 二、安装nodejs首先你都懂的，要装个node环境，因为Ionic和cordova的安装以及后续的许多前端工具的安装都依赖于node的包管理器npm。建议安装最新版本的node。没有装过的请看安装教程：http://www.runoob.com/nodejs/nodejs-install-setup.html 三、安装ionic1 安装全局的ionic cli：1npm install -g ionic 2 检测ionic是否安装成功：1ionic -v 3 创建ionic项目安装成功后，即可通过ionic cli命令创建ionic项目：1ionic start myApp tabs --type=angular （注意：目前ionic4是beta版，需要加上 –type=angular才能创建基于angular的项目，后面等发布正式版本，估计就不需要了） 说明：上面命令中tabs是ionic的其中一个模板，可以通过 ionic start --list 查看可选的模板。比如： ionic start myApp blank --type=angular 可以创建空白模板的ionic项目 4 下载ionic项目的node_modules包 在第三步创建ionic项目的过程中，ionic cli会自动帮你下载依赖的node_modules包（可以通过package.json查看项目所依赖的包），如果下载失败的话，可以删除node_modules文件夹，手动安装：npm install 5 运行ionic项目： ionic serveionic项目本身就是一个web h5项目，因此可以像vue、angular一样运行于浏览器。好了，ionic项目搭建成功后，接下来搭建cordova环境，然后利用cordova把ionic项目构建android工程。 四、安装cordova1 安装全局的cordova：npm install -g cordova 2 检测cordova是否安装成功：cordova -v 3 构建android工程1） 查看支持的平台以及版本：ionic cordova platform ls2） 构建android platform：ionic cordova platform add android 说明：此步骤会修改ionic的目录结构，让ionic支持cordova。构建成功后，会在platforms目录下生成一个android工程。 其他cordova命令：移除android工程：ionic cordova platform remove android添加指定版本的android工程：ionic cordova platform add android@6.0.0 至此，cordova环境已经搭建完成，并且利用ionic生成了一个android工程（位于/platforms/android）。但是此时还不能通过cordova编译该android工程，因为cordova编译android工程需要有android sdk的开发环境。所以，接下来配置android sdk环境。 五、配置android sdk环境1 安装jdk（下载、解压、配置环境变量）安装jdk可以参考这篇文章的jdk章节：https://blog.csdn.net/love4399/article/details/77164500用cmd 运行 javac -version 检查是否安装成功 2 安装android-sdk（下载、解压、配置环境变量）安装android-sdk可以参考这篇文章的android-sdk章节：https://blog.csdn.net/love4399/article/details/77164500用cmd 运行 adb –version 检查是否安装成功 3 安装gradle（下载、解压、配置环境变量）安装安装gradle可以参考这篇文章：https://jingyan.baidu.com/article/00a07f38706f0b82d028dcf3.html用cmd 运行 gradle -v 检查是否安装成功 以上环境搭建成功之后，即可通过cordova命令进行编译：ionic cordova build android，编译成功之后，会在/myApp/platforms/android/app/build/outputs/apk/debug目录下生成一个 xxx.apk。 六、构建第一个android应用至此，一个android apk就生成啦。最后总结一下利用ionic4+cordova构建android应用的过程：1 ionic start myApp blank–type=angular （创建ionic项目）2 ionic cordova platform add android （添加android平台）3 ionic cordova build android （编译生成apk）是不是很简单，前提是以上环境都已经搭建好了。 参考文档：1）cordova：https://baike.baidu.com/item/Cordova/9192368?fr=aladdin2）ionic：https://baike.baidu.com/item/ionic/1326386?fr=aladdin3）ionic开发android app步骤4）2017年Android SDK下载安装及配置教程：https://blog.csdn.net/love4399/article/details/77164500]]></content>
  </entry>
  <entry>
    <title><![CDATA[koa2实现文件上传]]></title>
    <url>%2Fblog%2F20180722%2Fundefined.html</url>
    <content type="text"><![CDATA[知识讲解koa2框架是一个基于中间件的框架，也就是说，需要使用到的功能，比如路由（koa-router），日志（koa-logger），都可以找到相应的中间件库，即npm包，然后通过app.use(…)引进来。本文的主题：实现文件上传就是通过引用相应的中间来实现的。我查了一下资料，发现可以实现文件上传的中间件有3个，选择其中一个就可以了：1）koa-body2）busboy3）koa-multer关于以上三种中间件的差异可以自行网上查资料，这里我选择比较顺眼的koa-body，实用简单。 代码实现步骤一：下载koa-body npm包1npm install koa-body --save 步骤二：在koa项目中引用koa-body中间件1234567const koaBody = require('koa-body');app.use(koaBody(&#123; multipart: true, formidable: &#123; maxFileSize: 200*1024*1024 // 设置上传文件大小最大限制，默认2M &#125;&#125;)); 步骤三：使用koa-body中间件后，即可通过ctx.request.files获取上传的文件提醒： 新版本的koa-body通过ctx.request.files获取上传的文件 旧版本的koa-body通过ctx.request.body.files获取上传的文件 朋友们千万不要入坑哈，本人就入坑过半天。 步骤四：获取到文件之后，通过fs将文件保存到服务器的指定目录上传单个文件：123456789101112router.post('/uploadfile', async (ctx, next) =&gt; &#123; // 上传单个文件 const file = ctx.request.files.file; // 获取上传文件 // 创建可读流 const reader = fs.createReadStream(file.path); let filePath = path.join(__dirname, 'public/upload/') + `/$&#123;file.name&#125;`; // 创建可写流 const upStream = fs.createWriteStream(filePath); // 可读流通过管道写入可写流 reader.pipe(upStream); return ctx.body = "上传成功！";&#125;); 上传多个文件:123456789101112131415router.post('/uploadfiles', async (ctx, next) =&gt; &#123; // 上传多个文件 const files = ctx.request.files.file; // 获取上传文件 for (let file of files) &#123; // 创建可读流 const reader = fs.createReadStream(file.path); // 获取上传文件扩展名 let filePath = path.join(__dirname, 'public/upload/') + `/$&#123;file.name&#125;`; // 创建可写流 const upStream = fs.createWriteStream(filePath); // 可读流通过管道写入可写流 reader.pipe(upStream); &#125; return ctx.body = "上传成功！";&#125;); 前端代码顺便把前端的代码也附上，前端通过提交表单，把文件发送到你的服务器 1234&lt;form action="http://localhost:8080/api/upload" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="file" id="file" value="" multiple="multiple" /&gt; &lt;input type="submit" value="提交"/&gt;&lt;/form&gt; 最后总结今天在项目中实现文件上传的时候，也一不小心入了一下坑，为什么呢？（请看以上步骤三）在网上找的大部分资料都是通过ctx.request.body.files来获取上传的文件，这个是旧版本的koa-body的获取文件方法，为了安全考虑，新版本的koa-body采用ctx.request.files来获取文件。总结原因，以后要学会找官方文档，以官方文档为主，其他文档为辅，这样才对。]]></content>
  </entry>
</search>
