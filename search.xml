<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基于js对观察订阅者模式的一些体会和应用场景]]></title>
    <url>%2Fblog%2F20181124%2F19bf8033.html</url>
    <content type="text"><![CDATA[1、自己实现一个简单版的rxjs：SimpleObservable1234567891011121314151617181920212223242526SimpleObservable.tsclass SimpleObservable &#123; private observer: Array&lt;Function&gt;; constructor() &#123; this.observer = []; &#125; subscribe(_observer: Function) &#123; this.observer.push(_observer); let _index = this.observer.length - 1; let that = this; return &#123; _index: _index, unsubscribe: function () &#123; console.log("before:unsubscribe:", that.observer); that.observer.splice(this._index, 1); console.log("after :unsubscribe:", that.observer); &#125; &#125;; &#125; next(_data: any) &#123; for (let i = 0, len = this.observer.length; i &lt; len; i++) &#123; this.observer[i](_data); &#125; &#125;&#125;export default SimpleObservable; 2、实现监听场景：在项目中，不同页面的header样式一样，只有title文字不一样，比如page1显示的titile是’page1’，而page2显示的titile是’page2’,于是我把header做成了一个组件，而每个页面也是一个组件，因此通过SimpleObservable就可以实现组件与组件间的间接单向通信，即观察者（observer）监听被观察者（observable），被观察者触发观察者。 （备注：以下用ts语法，可以通过tsc编译生成对应js，再运行） 大致代码如下： demo1 1234567891011121314151617demo1.tsimport SimpleObservable from './SimpleObservable';let subscriptions=[];let headerTitleObservable = new SimpleObservable();let headerTitle_subscriptsion = headerTitleObservable .subscribe(_title =&gt; &#123; console.log(`the header title is change to$&#123;_title &#125;`); &#125;);subscriptions.push(headerTitle_subscriptsion );// 触发this.headerTitleObservable.next('page1');// 在组件生命周期结束时，清除所有observerssubscriptions.forEach(subscription =&gt; &#123; subscription.unsubscribe(); &#125;); 2、解除两个类的强耦合状态使用观察订阅者模式，有时候能解除两个类的强耦合状态，比如，在我的项目中，我写了一个http拦截器httpInterceptor,用来过滤每一次http请求和响应，比如统一加access_token header，统一出错处理啊等等，我的httpInterceptor其中的一个功能，就是从服务器返回的响应头中检测登录状态是否已经失效或access_token是否已经过期，当检测到登录失效时，要在页面中弹出一个登录modal框（loginModalComponent），提醒用户重新登录。大致的代码如下： (备注：以下采用ts语法，为了使理解起来更加容易，没有使用ts的依赖注入等特性) 未使用观察者模式： demo2 12345678910111213141516171819202122232425262728293031demo2.ts/** * 这里模拟了一个登录modal组件 */class LoginModalComponent &#123; constructor() &#123; &#125; open() &#123; console.log('##检测到access_token已经过期，打开login模态框##'); console.log('请输入账号和密码,点击登录'); &#125;&#125;/** * 这里模拟了一个http拦截器 */class HttpInterceptor &#123; loginModalComponent: LoginModalComponent = new LoginModalComponent();; constructor() &#123; &#125; handleHttpRes() &#123; if (this.checkLoginInvalid) &#123; this.loginModalComponent.open(); &#125; &#125; // 检查登录是否失效 checkLoginInvalid() &#123; return true; &#125;&#125;let httpInterceptor = new HttpInterceptor();httpInterceptor.handleHttpRes(); 以上示例代码是未使用观察者模式的情况下，需要在HttpInterceptor里new LoginModalComponent,从而导致HttpInterceptor和LoginModalComponent处于强耦合的状态，但是这样不符合HttpInterceptor拦截器的思想，因为HttpInterceptor拦截器是不应该和组件相关的东西进行耦合的，因此，采用观察者模式进行改进. 代码如下： demo3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101demo3.tsclass SimpleObservable &#123; private observer: Array&lt;Function&gt;; constructor() &#123; this.observer = []; &#125; subscribe(_observer: Function) &#123; this.observer.push(_observer); let _index = this.observer.length - 1; let that = this; return &#123; _index: _index, unsubscribe: function () &#123; console.log("before:unsubscribe:", that.observer); that.observer.splice(this._index, 1); console.log("after :unsubscribe:", that.observer); &#125; &#125;; &#125; next(_data: any) &#123; for (let i = 0, len = this.observer.length; i &lt; len; i++) &#123; this.observer[i](_data); &#125; &#125;&#125;/** * 这里模拟了一个登录modal组件 */class LoginModalComponent &#123; constructor() &#123; &#125; open() &#123; console.log('##检测到access_token已经过期，打开login模态框##'); console.log('请输入账号和密码,点击登录'); &#125;&#125;/** * 通过一个service来作为中间者，从而解除HttpInterceptor和LoginModalComponent强耦合状态。 */class HttpStatusService &#123; login_invalid_observable = new SimpleObservable(); constructor() &#123; &#125; getLoginInvalidObservable() &#123; return this.login_invalid_observable; &#125; triggerLoginInvalidObservable() &#123; this.login_invalid_observable.next('access_token is invalid.') &#125;&#125;/** * 创建一个HttpStatusService的实例，全局可用，实际的做法是采用ts的依赖注入 */let httpStatusService: HttpStatusService = new HttpStatusService();/** * 这里模拟了一个http拦截器 */class HttpInterceptor &#123; constructor() &#123; &#125; handleHttpRes() &#123; if (this.checkLoginInvalid) &#123; httpStatusService.triggerLoginInvalidObservable(); &#125; &#125; // 模拟一个登录失败的状态，实际的情况是，拦截到http请求的服务器响应信息 checkLoginInvalid() &#123; return true; &#125;&#125;/** * AppComponent,一个页面跟组件 */class AppComponent &#123; loginModalComponent: LoginModalComponent = new LoginModalComponent(); subscriptions: Array&lt;any&gt; = []; constructor() &#123; this.init(); &#125; init() &#123; let subscription1 = httpStatusService.getLoginInvalidObservable().subscribe((err_msg) =&gt; &#123; this.loginModalComponent.open(); &#125;); this.subscriptions.push(subscription1); &#125; onDestroy() &#123; this.subscriptions.forEach(subscription =&gt; &#123; subscription.unsubscribe(); &#125;); &#125;&#125;let appComponent = new AppComponent();/** * 此时appComponent已经在监听httpStatusService里的login_invalid_observable */let httpInterceptor = new HttpInterceptor();httpInterceptor.handleHttpRes();appComponent.onDestroy();]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于js（es5）如何优雅地创建对象]]></title>
    <url>%2Fblog%2F20181115%2F7df91c4c.html</url>
    <content type="text"><![CDATA[一、前颜（yan）对象（Object Oriented，OO）对于基于类的语言来说是再普通不过的一个概念 了，比如C++，Java等等。而在es5（以下js指es5）中，由于没有类的概念，因此它的对象与其他基于类的语言的对象是不同的。因此在js中，关于对象的创建方法也有所不一样。本文介绍各种创建js对象的方法，以及优缺点。 二、通过Object创建对象123456var cat = new Object();cat.name = 'kiki1';cat.age = 1;cat.speak = function () &#123; console.log('Hello I am ', this.name);&#125; 缺点：当需要创建多个相似对象时，会产生大量的重复代码，比如这时候我想再创建一个cat2，这时就得重复一遍以上代码。123456var cat2 = new Object();cat2.name = 'kiki2';cat2.age = 2;cat2.speak = function () &#123; console.log('Hello I am ', this.name);&#125; 三、通过对象字面量语法对象1234567var cat = &#123; name: 'kiki1', age: 1, speak: function () &#123; console.log('Hello I am ', this.name); &#125;&#125; 特点：通过此方法来创建对象相比Object创建对象代码简洁了很多缺点：与通过Object创建对象的缺点一致 为了解决以上问题，以下模式来了。 四、通过工厂模式创建对象123456789101112131415function createCat(name, age) &#123; var o = new Object(); o.name = name; o.age = age; o.speak = function () &#123; console.log('Hello I am ', this.name); &#125; return o;&#125;var cat1=createCat('kiki1',1);var cat2=createCat('kiki2',2);cat1.speak(); //Hello I am kiki1cat2.speak(); //Hello I am kiki2 特点：通过工厂模式创建对象，可以解决创建多个相似对象的问题。缺点：无法识别对象，即无法知道一个对象的类型。 五、通过构造函数模式创建对象通过构造函数模式创建对象，能够很好的解决工厂模式创建对象的问题。 1234567891011121314151617181920function Cat(name, age) &#123; this.name = name; this.age = age; this.speak = function () &#123; console.log('Hello I am ', this.name); &#125;&#125;let cat1 = new Cat('kiki1', 1);let cat2 = new Cat('kiki2', 2);cat1.speak(); //Hello I am kiki1cat2.speak(); //Hello I am kiki2// 检测对象类型console.log(cat1 instanceof Cat); // trueconsole.log(cat2 instanceof Cat); // true// 不同实例上的同名函数是不相等console.log(cat1.speak == cat2.speak); // false 特点：1、通过new Cat来创建实例2、可以通过instanceof来检测对象类型缺点：使用构造函数的缺点在于，每个方法都会在实例上重新创建一遍，所以不同实例上的同名函数是不相等的,即无法共享方法。比如上面的例子中的cat1.speak和cat2.speak是不相等的。 为了解决此缺点，请看原型模式。 六、原型模式123456789101112131415161718function Cat() &#123; &#125;Cat.prototype.name = 'kiki1';Cat.prototype.age = 1;Cat.prototype.speak = function () &#123; console.log('Hello I am ', this.name);&#125;Cat.prototype.data = [1, 2];let cat1 = new Cat();let cat2 = new Cat();console.log(cat1.speak == cat2.speak); // true// 引用类型属性，不同实例之间互相影响console.log(cat2.data); // [1,2]cat1.data.push(3);console.log(cat1.data); // [1,2,3]console.log(cat2.data); // [1,2,3] 特点：共享方法，比如上面的例子中，cat1.speak和cat2.speak是相等的。缺点：由于引用类型的属性也是共享的，因此不同实例之间会互相影响 六、组合模式组合模式：即构造函数模式+原型模式。采用组合模式可以解决构造函数模式和原型模式的问题，又拥有构造函数和原型模式的特点，集两种模式之长。通过构造函数模式定义实例属性，通过原型模式定义共享方法和共享属性。 12345678910111213141516function Cat(name, age, data) &#123; this.name = name; this.age = age; this.data = data;&#125;Cat.prototype.speak = function () &#123; console.log('Hello I am ', this.name);&#125;let cat1 = new Cat('kiki1', 1, [1, 2, 3]);let cat2 = new Cat('kiki2', 2, [3, 4, 5]);console.log(cat1.speak == cat2.speak); // trueconsole.log(cat1.data); // [1,2,3]console.log(cat2.data); // [3,4,5] 综上对比，组合模式是最优雅的创建对象的方式。]]></content>
  </entry>
  <entry>
    <title><![CDATA[基于mocha、should.js、karma、travis ci实现前端自动化持续测试]]></title>
    <url>%2Fblog%2F20181108%2F16dc22b.html</url>
    <content type="text"><![CDATA[前颜（yan）首先你觉得测试重要吗？为什么重要？ 这里举个例子，假如你写了一个逻辑稍微比较复杂的函数，这个函数被很多地方调用到，那么当过了N多天之后，你可能快要忘记这里面的逻辑了，此时你可能出于某种原因需要为这个函数增加一些功能，修改这个函数的代码，那么你要怎么做才能做到修改后不影响其他的调用者呢，或者说，你要怎么做，才能快速的知道哪些地方受影响，哪些地方不受影响呢？ 很明显，答案就是：跑测试用例 对于单元测试，我能想到的好处有： 改进代码设计，提高代码质量：单元测试会强制你对代码进行合理的设计，解耦，写出可测试的代码 允许重构，你可以放心的对代码进行修改，因为你有测试用例来确保你的代码能够按符合预期要求 快速定位bug 既然单元测试这么重要，那么就应该好好重视起来。 前端测试框架和库目前前端测试框架和库主要有assert、should.js、expect、chai、mocha、jasmine、karma以及travis ci等等。 其中assert、should.js、expect、chai属于断言库，实现对js代码进行断言测试。 ​而mocha、jasmine属于测试框架，测试框架通过使用断言库对js代码进行测试，生成测试报告，除此之外，测试框架还提供了各种生命周期。 ​karma则属于测试工具，能够模拟各种环境来运行你的测试代码，比如Chrome，Firefox，mobile等等。 ​重点要介绍的是travis ci，是一个远程免费的持续集成（CI）服务，你可以通过配置绑定你github上的项目，并且配置运行环境，实现只要github上有代码更新，travis就会自动运行构建和测试，并反馈运行结果。 ​下面对不同断言库进行简单的介绍： ​断言库（主要实现对代码进行测试） assert ：TDD风格断言，是nodejs的一个断言测试模块，提供的api不是很多 1assert.equal(foo, 'foo'); should.jd：BDD风格断言库，should相对于assert有比较丰富的api，并且其语法非常的语义化 123foo.should.be(); bar.should.have();foo.should.bot.be(); expect：BDD风格断言，语法和should.js类似 1234expect(foo).to.be();expect(foo).to.eql();expect(foo).to.be.a();expect(foo).not.to.be.an(); chai：支持BDD/TDD双模式，同时支持should/expect/assert三种风格的断言库，还有强大的插件机制 1234567891011shouldchai.should();foo.should.be.a('string');expectvar expect = chai.expect;expect(foo).to.be.a('string');assertvar assert = chai.assert;assert.typeOf(foo, 'string'); 接下来，我将使用mocha、should.js、karma、travis ci实现几个前端js自动化持续测试的demo。大家可以克隆相应的代码下来对应着看，由于篇幅有限，下面只讲关键点。 demo1(mocha+should.js)特点：直接使用mocha和should.js来跑测试用例。 代码地址：https://github.com/SimpleCodeCX/myCode/tree/master/test/demo1 关键点说明： 1 下载相关依赖（mocha和should.js） 12npm instal -g mocha （全局）npm install --save-dev should 2 添加主功能（待测试）代码 12345#src/main.jsfunction add(x, y) &#123; return x + y;&#125;module.exports = add; 3 添加测试用例 12345678#test/test.jsvar add = require('../src/main')describe('add', function () &#123; it('8 + 8 = 16', function () &#123; add(8, 8).should.equal(16); &#125;)&#125;) 4 配置mocha.opts 12#test/mocha.opts--require should 关于mocha.opts的更多配置（代替命令行参数）：https://mochajs.org/#mochaopts 5 运行 1mocha 输出测试结果 123456&gt;mochaadd √ 8 + 8 = 16 1 passing (10ms) demo2(mocha+should.js+karma)特点： 通过karma调用mocha测试框架来进行代码测试 优点在于karma能模拟浏览器比如Chrome、Firefox来运行测试代码 代码地址：https://github.com/SimpleCodeCX/myCode/tree/master/test/demo2 关键点说明： 1 下载相关依赖（mocha、should.js和karma） 12345npm install --save-dev mocha（demo1使用的是全局mocha，这里是karma调用mocha）npm install --save-dev shouldnpm install --save-dev karmanpm install --save-dev karma-chrome-launchernpm install --save-dev karma-mocha 2 添加主功能（待测试）代码 12345#src/main.js(注意和demo1的区别)function add(x, y) &#123; return x + y;&#125; 3 添加测试用例 1234567#test/test.js(注意和demo1的区别)describe('add', function () &#123; it('8 + 8 = 16', function () &#123; add(8, 8).should.equal(16); &#125;)&#125;) 4 配置karma（karma.conf.js） 运行 karma init，按提示操作。 12345678910111213141516171819202122232425262728293031Which testing framework do you want to use ?Press tab to list possible options. Enter to move to the next question.&gt; mochaDo you want to use Require.js ?This will add Require.js plugin.Press tab to list possible options. Enter to move to the next question.&gt; noDo you want to capture any browsers automatically ?Press tab to list possible options. Enter empty string to move to the next question.&gt; Chrome&gt;What is the location of your source and test files ?You can use glob patterns, eg. &quot;js/*.js&quot; or &quot;test/**/*Spec.js&quot;.Enter empty string to move to the next question.&gt; test/**/*.js&gt;Should any of the files included by the previous patterns be excluded ?You can use glob patterns, eg. &quot;**/*.swp&quot;.Enter empty string to move to the next question.&gt;Do you want Karma to watch all the files and run the tests on change ?Press tab to list possible options.&gt; yesConfig file generated at &quot;...\demo2\karma.conf.js&quot;. 然后在karma.conf.js中的files添加相关的依赖模块：12345files: [ &apos;node_modules/should/should.js&apos;, &apos;test/**/*.js&apos;, &apos;src/**/*.js&apos; ] 关于karma的更多配置：http://karma-runner.github.io/3.0/config/configuration-file.html 5 运行 1karma start karma会运行chrome浏览器，并且输出测试结果 1234567&gt;karma start08 11 2018 21:01:34.765:WARN [karma]: No captured browser, open http://localhost:9876/08 11 2018 21:01:34.775:INFO [karma]: Karma v1.7.1 server started at http://0.0.0.0:9876/08 11 2018 21:01:34.775:INFO [launcher]: Launching browser Chrome with unlimited concurrency08 11 2018 21:01:34.785:INFO [launcher]: Starting browser Chrome08 11 2018 21:01:37.456:INFO [Chrome 70.0.3538 (Windows 7.0.0)]: Connected on socket h9aSRbkdzZNTgb2dAAAA with id 46125810Chrome 70.0.3538 (Windows 7.0.0): Executed 1 of 1 SUCCESS (0.007 secs / 0.002 secs) demo3(mocha+should.js+karma+travis)代码地址：https://github.com/SimpleCodeCX/myCode/tree/master/test/demo3 1 复制demo2的工程作为demo3 2 在github上创建一个新工程demo3，并关联本地仓库 1git remote add origin git@github.com:SimpleCodeCX/demo3.git 3 使用github账号登录travis官网，同步并激活监听github上的demo3项目 参考文章：http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html 4 配置travis（.travis.yml） 在demo3的根目录下新建.travis.yml文件，并做如下配置：123456789language: node_jsnode_js: - &quot;8&quot;script: karma start --single-runbefore_install: - npm install - export CHROME_BIN=chromium-browser - export DISPLAY=:99.0 - sh -e /etc/init.d/xvfb start 5 提交到远程仓库上 123git add . git commit -m &apos;add travis ci&apos;git push origin master 6 此时可以在travis上查看测试反馈 有关travis的配置文档：https://docs.travis-ci.com/user/languages/javascript-with-nodejs/ 参考文档：https://nodejs.org/api/assert.htmlhttps://github.com/shouldjs/should.jshttps://github.com/Automattic/expect.jshttps://www.chaijs.comhttps://mochajs.orghttps://jasmine.github.iohttp://karma-runner.github.iohttps://docs.travis-ci.com/user/languages/javascript-with-nodejs]]></content>
  </entry>
  <entry>
    <title><![CDATA[基于nodejs的雪碧图制作工具]]></title>
    <url>%2Fblog%2F20181103%2Fd968dc4.html</url>
    <content type="text"><![CDATA[前颜（yan）雪碧图（CSS sprite ），就是把很多小图标合并为一张图片。 在Web开发中，使用雪碧图是优化Web性能的一种方法。 比如你可能遇到过这样的一种场景：在你的页面中，使用到了很多的小图标，然后你的每个小图标都是通过img src来引用的。比如：1&lt;img src='logo.png'&gt; 通过这种方式虽然比较方便，但是存在的一个缺点就是性能问题，即浏览器在解析每个小图标时，都要发起一次http或（https）请求，而这个小图标本身却很小，可能只有十几k甚至几k，那么为每个小图标单独发起http请求，其实有点资源浪费。 为什么会资源浪费呢？ 浏览器在与服务器进行http请求的过程中，需要有一个类似握手通信的过程，然后才是真正的获取数据。 举个例子，在这里我把浏览器发起的http图片请求简单分为两个过程，分别为： 1、浏览器与服务器的通信握手过程，假设耗时X ms（毫秒） 2、真正的数据获取过程，假设耗时 Y ms（毫秒） 那么浏览器发起一次http请求的总耗时为：sum(1)=X+Y ms，由于小图标数据很小，可能只有几k，因此通信过程的耗时X是大于Y的。 而当你在网页中引用了很多小图标时，假设有n个小图标，此时总耗时为sum(n)=nX+nY ms，通过对比sum(1)和sum(n)，你就会发现，上面所说的资源浪费主要是在于通信握手的时间Y。此时，我就会想，如果我一次性取得所有的小图标，那么总耗时就变成了sum(n)=nX+Y ms，这样就能节省(n-1)Y的http握手通信的时间开销，从而优化了web的响应性能。 一、雪碧图抠图（background-position）通过前面的介绍，我们知道，雪碧图的原理就是将页面中使用到的小图标合成为一张总图。这样的话当我们想要使用雪碧图中的某一个小图标，应该通过如何实现呢？ 答案是通过css的background-position，background-position的默认坐标是（0，0），关于background-position的详细使用，大家可以网上搜索一下，资料很多。（这次主要讲雪碧图制作工具） 二、雪碧图制作工具 simple-sprite那么如何合成雪碧图呢？怎样才能更方便的合成雪碧图呢？ 因为懒，我的想法是，每次当我需要合成雪碧图时，我只要经过以下尽量简单的步骤就可以快速合成，并且可以导出各个小图标在雪碧图中的background-position css样式。为此，我用nodejs写了一个雪碧图制作工具：simple-sprite，并打包生成npm包发布至npm官网。 雪碧图制作步骤如下： 1 创建雪碧图生成工程 12mkdir sprite-generatorcd sprite-generator 2 初始化工程1npm init 3 把所有小图标放到imgs中1mkdir imgs &amp;&amp; 把所有的小图标放到imgs中 4 下载 simple-sprite npm包1npm install --save simple-sprite 5 运行生成雪碧图123let sprite = require('simple-sprite');sprite.generateSprite('./imgs'); simple-sprite：https://www.npmjs.com/package/simple-sprite 三、github源码构建工具：rollup github源码：https://github.com/SimpleCodeCX/simple-sprite#readme （如果你点开了我的github源码连接，顺便也帮我点个star哦！哈哈）]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Diffie-Hellman密钥协商算法]]></title>
    <url>%2Fblog%2F20180923%2F4db4f43.html</url>
    <content type="text"><![CDATA[加密算法介绍目前常用的加密算法主要有：哈希算法（比如MD5、SHA族、Hmac），对称加密算法（比如AES），非对称加密算法（RSA），以及Diffie-Hellman密钥协商算法等等，这几种算法都有各自的特点，适合的场景也不一样，这里只做简单的介绍，想详细了解的话，网上资料很多，可以自行查看相关的资料。 各类算法的特点： 哈希算法：正向快速，不可逆性，即加密后是很难解密出明文的。经常用于数据加密和数据校验。 对称加密算法：AES是一种常用的对称加密算法，其特点是加解密都用同一个密钥。 非对称加密算法RSA：RSA算法是一种非对称加密算法，由一个私钥和一个公钥构成的密钥对，通过私钥加密，公钥解密，或者通过公钥加密，私钥解密。其中，公钥可以公开，私钥必须保密。 Diffie-Hellman密钥协商算法：Diffie-Hellman是一种密钥协商算法（简称DH算法），DH算法基于一种数学原理，能够在双方不泄露密钥的情况下协商出一种密钥来。 场景描述在客户端向服务器端发送数据的过程中，如果是比较重要的数据（比如密码，敏感数据等），一般需要先在客户端进行加密后再发送，服务器接收到数据后再进行解密得到原始数据。(反过来服务器返回数据给客户端也是一样的道理) 这里假设客户端和服务器端采用AES（对称加密算法）进行加解密传输的数据，AES加密算法有一个特点就是加解密都用同一个密钥（这里把该密钥称作secretKey），所以双方都通过secretKey进行数据加解密。 因此在客户端向服务器第一次传输数据的时候，客户端需要先向服务器端获取secretKey，并且保存在客户端，而这种直接向服务器获取明文secretKey的过程是很容易被第三者拦截的，也就是说这一过程是不安全的。（哈哈，除非是服务器把secretKey写到纸上，亲手偷偷地递给客户端） 因此呢，客户端向服务器获取secretKey的这一过程，也是需要进行加密的。 那么，服务器需要怎么做才能把secretKey安全的送达客户端呢？ 目前常采用的方法有：RSA 或 Diffie-Hellman 通过RSA安全传输密钥RSA有一个公钥和一个私钥，公钥是允许公开出去的，私钥是保留的。RSA的要点在于用公钥加密的数据需要用私钥解密，用私钥加密的数据，需要用公钥解密。因此，比如这时候客户端把公钥发送给服务器，服务器利用客户端的公钥对secretKey进行加密，那么这份加密后的secretKey数据，就只有客户端的私钥能解开啦。即使第三者拿到了这份数据也解密不了，除非能获取到客户端的私钥。 所以，通过RSA的方式，服务器就能把secretKey安全的传递到客户端的手里啦。（不过，RSA也是有安全漏洞的，被称作中间人攻击，由于篇幅原因，这里就先不讲啦！大家自行百度。） 虽然使用RSA能够安全的传输secretKey密钥，但是麻烦点在于需要生成一对公钥和私钥，并且把公钥发送给对方，而且加解密速度比较慢。所以，介绍第二种：Diffie-Hellman密钥协商算法。 通过DH算法协商密钥严格来说，DH算法其实并不是一种加密算法，因为它本身并不是用于加密的，我的理解是用于双方协商计算，即双方按照某种合约进行计算，从而计算出一种相同的结果。 原理如下： 第一步：初始化 &nbsp;&nbsp;&nbsp;&nbsp;比如现在服务器提供了两个随机公钥数字（允许公开）：pubN=10，modN=3; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端自己生成了一个随机私钥数字（不可公开，服务器也不知道）：cPrivN=2; 服务器端也自己生成了一个随机私钥数字（不可公开，客户端也不知道）：sPrivN=4; 第二步：客户端、服务器端分别基于相同的数学公式进行计算，计算结果称作公钥结果：pubResult 客户端进行数学计算：cPubResult = pubN cPrivN % modN = 10 2 % 3 = 2；（计算结果允许公开） 服务器进行数学计算：sPubResult = pubN sPrivN % modN = 10 4 % 3 = 1；（计算结果允许公开） 客户端和服务器端交换公钥结果，客户端得到sPubResult=1，服务器端得到cPubResult=2。 第三步：协商出一致的密钥数字:keyN（客户端和服务器端得出的结果是一致的） 客户端：cKeyN = sPubResult cPrivN % modN= 1 2 % 3 = 2；服务器：sKeyN = cPubResult sPrivN % modN= 2 4 % 3 = 2； 到目前为止呢，双方都协商出了密钥，并且是一致的，但是呢，有没有见过密钥是number类型的？想必都没有吧，所以需要进行第四步，生成更长的密钥。 第四步：对密钥数字进行hash生成密钥串 123const hash = crypto.createHash('sha256');hash.update(this.keyN.toString());this.secretKey = hash.digest('hex');]]></content>
  </entry>
  <entry>
    <title><![CDATA[基于ionic4、cordova搭建android开发环境]]></title>
    <url>%2Fblog%2F20180827%2Fa09cfe7a.html</url>
    <content type="text"><![CDATA[前颜（yan）最近公司有一个项目需求是利用h5进行跨平台开发，这里所说的跨平台开发指的是：将h5代码利用某种方式或工具环境进行打包，最后生成android的apk以及ios的ipa。本文只讲解android开发环境，等以后有空了再介绍一篇关于ios的。 一、知识讲解本文基于ionic4+cordova构建android应用，首先做一下以下的知识梳理。 1 ionic是一套用于开发混合手机应用的开源h5框架，包含一套适合于mobile application的ui组件库以及相关访问原生设备的native接口等。目前ionic已更新至ionic4，ionic4的特色在于兼容angular6以及rxjs6，有着angular6的特点，因此，angular的开发者可以很容易的切换到ionic4的开发。ionic官方文档：https://beta.ionicframework.com/docs/intro 2 cordova是一套开源的移动应用开发框架。cordova能够利用web应用（如ionic构建的h5应用）构建android工程以及ios工程（今天只讲android工程）。并且可以编译android工程，最后生成android apk。cordova官方文档：https://cordova.apache.org/docs/en/latest/guide/overview/index.html 3 android sdkcordova在编译android工程的时候需要有android sdk等开发环境的支持。如果想对ionic和cordova更加详细的了解，请见官方文档。 接下来，开始搭建开发环境。因此，综上所述，需要搭建的开发环境有：ionic、cordova以及android 开发环境。 我的开发环境如下（仅供参考）：node：v8.11.1npm：5.5.1ionic：4.0.3cordova：8.0.0jdk：1.8.0_45gradle：4.9 二、安装nodejs首先你都懂的，要装个node环境，因为Ionic和cordova的安装以及后续的许多前端工具的安装都依赖于node的包管理器npm。建议安装最新版本的node。没有装过的请看安装教程：http://www.runoob.com/nodejs/nodejs-install-setup.html 三、安装ionic1 安装全局的ionic cli：1npm install -g ionic 2 检测ionic是否安装成功：1ionic -v 3 创建ionic项目安装成功后，即可通过ionic cli命令创建ionic项目：1ionic start myApp tabs --type=angular （注意：目前ionic4是beta版，需要加上 –type=angular才能创建基于angular的项目，后面等发布正式版本，估计就不需要了） 说明：上面命令中tabs是ionic的其中一个模板，可以通过 ionic start --list 查看可选的模板。比如： ionic start myApp blank --type=angular 可以创建空白模板的ionic项目 4 下载ionic项目的node_modules包 在第三步创建ionic项目的过程中，ionic cli会自动帮你下载依赖的node_modules包（可以通过package.json查看项目所依赖的包），如果下载失败的话，可以删除node_modules文件夹，手动安装：npm install 5 运行ionic项目： ionic serveionic项目本身就是一个web h5项目，因此可以像vue、angular一样运行于浏览器。好了，ionic项目搭建成功后，接下来搭建cordova环境，然后利用cordova把ionic项目构建android工程。 四、安装cordova1 安装全局的cordova：npm install -g cordova 2 检测cordova是否安装成功：cordova -v 3 构建android工程1） 查看支持的平台以及版本：ionic cordova platform ls2） 构建android platform：ionic cordova platform add android 说明：此步骤会修改ionic的目录结构，让ionic支持cordova。构建成功后，会在platforms目录下生成一个android工程。 其他cordova命令：移除android工程：ionic cordova platform remove android添加指定版本的android工程：ionic cordova platform add android@6.0.0 至此，cordova环境已经搭建完成，并且利用ionic生成了一个android工程（位于/platforms/android）。但是此时还不能通过cordova编译该android工程，因为cordova编译android工程需要有android sdk的开发环境。所以，接下来配置android sdk环境。 五、配置android sdk环境1 安装jdk（下载、解压、配置环境变量）安装jdk可以参考这篇文章的jdk章节：https://blog.csdn.net/love4399/article/details/77164500用cmd 运行 javac -version 检查是否安装成功 2 安装android-sdk（下载、解压、配置环境变量）安装android-sdk可以参考这篇文章的android-sdk章节：https://blog.csdn.net/love4399/article/details/77164500用cmd 运行 adb –version 检查是否安装成功 3 安装gradle（下载、解压、配置环境变量）安装安装gradle可以参考这篇文章：https://jingyan.baidu.com/article/00a07f38706f0b82d028dcf3.html用cmd 运行 gradle -v 检查是否安装成功 以上环境搭建成功之后，即可通过cordova命令进行编译：ionic cordova build android，编译成功之后，会在/myApp/platforms/android/app/build/outputs/apk/debug目录下生成一个 xxx.apk。 六、构建第一个android应用至此，一个android apk就生成啦。最后总结一下利用ionic4+cordova构建android应用的过程：1 ionic start myApp blank–type=angular （创建ionic项目）2 ionic cordova platform add android （添加android平台）3 ionic cordova build android （编译生成apk）是不是很简单，前提是以上环境都已经搭建好了。 参考文档：1）cordova：https://baike.baidu.com/item/Cordova/9192368?fr=aladdin2）ionic：https://baike.baidu.com/item/ionic/1326386?fr=aladdin3）ionic开发android app步骤4）2017年Android SDK下载安装及配置教程：https://blog.csdn.net/love4399/article/details/77164500]]></content>
  </entry>
  <entry>
    <title><![CDATA[koa2实现文件上传]]></title>
    <url>%2Fblog%2F20180722%2Fundefined.html</url>
    <content type="text"><![CDATA[知识讲解koa2框架是一个基于中间件的框架，也就是说，需要使用到的功能，比如路由（koa-router），日志（koa-logger），都可以找到相应的中间件库，即npm包，然后通过app.use(…)引进来。本文的主题：实现文件上传就是通过引用相应的中间来实现的。我查了一下资料，发现可以实现文件上传的中间件有3个，选择其中一个就可以了：1）koa-body2）busboy3）koa-multer关于以上三种中间件的差异可以自行网上查资料，这里我选择比较顺眼的koa-body，实用简单。 代码实现步骤一：下载koa-body npm包1npm install koa-body --save 步骤二：在koa项目中引用koa-body中间件1234567const koaBody = require('koa-body');app.use(koaBody(&#123; multipart: true, formidable: &#123; maxFileSize: 200*1024*1024 // 设置上传文件大小最大限制，默认2M &#125;&#125;)); 步骤三：使用koa-body中间件后，即可通过ctx.request.files获取上传的文件提醒： 新版本的koa-body通过ctx.request.files获取上传的文件 旧版本的koa-body通过ctx.request.body.files获取上传的文件 朋友们千万不要入坑哈，本人就入坑过半天。 步骤四：获取到文件之后，通过fs将文件保存到服务器的指定目录上传单个文件：123456789101112router.post('/uploadfile', async (ctx, next) =&gt; &#123; // 上传单个文件 const file = ctx.request.files.file; // 获取上传文件 // 创建可读流 const reader = fs.createReadStream(file.path); let filePath = path.join(__dirname, 'public/upload/') + `/$&#123;file.name&#125;`; // 创建可写流 const upStream = fs.createWriteStream(filePath); // 可读流通过管道写入可写流 reader.pipe(upStream); return ctx.body = "上传成功！";&#125;); 上传多个文件:123456789101112131415router.post('/uploadfiles', async (ctx, next) =&gt; &#123; // 上传多个文件 const files = ctx.request.files.file; // 获取上传文件 for (let file of files) &#123; // 创建可读流 const reader = fs.createReadStream(file.path); // 获取上传文件扩展名 let filePath = path.join(__dirname, 'public/upload/') + `/$&#123;file.name&#125;`; // 创建可写流 const upStream = fs.createWriteStream(filePath); // 可读流通过管道写入可写流 reader.pipe(upStream); &#125; return ctx.body = "上传成功！";&#125;); 前端代码顺便把前端的代码也附上，前端通过提交表单，把文件发送到你的服务器 1234&lt;form action="http://localhost:8080/api/upload" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="file" id="file" value="" multiple="multiple" /&gt; &lt;input type="submit" value="提交"/&gt;&lt;/form&gt; 最后总结今天在项目中实现文件上传的时候，也一不小心入了一下坑，为什么呢？（请看以上步骤三）在网上找的大部分资料都是通过ctx.request.body.files来获取上传的文件，这个是旧版本的koa-body的获取文件方法，为了安全考虑，新版本的koa-body采用ctx.request.files来获取文件。总结原因，以后要学会找官方文档，以官方文档为主，其他文档为辅，这样才对。]]></content>
  </entry>
</search>
