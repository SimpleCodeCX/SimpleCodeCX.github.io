<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[教程2]]></title>
    <url>%2F2018%2F11%2F05%2F%E6%95%99%E7%A8%8B2%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[教程]]></title>
    <url>%2F2018%2F11%2F05%2F%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"></content>
      <categories>
        <category>Hexo教程</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2018%2F10%2F17%2Ftest%2F</url>
    <content type="text"><![CDATA[1232]]></content>
      <categories>
        <category>2</category>
      </categories>
      <tags>
        <tag>1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start11111111111111111111111111111111111111 Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Diffie-Hellman密钥协商算法]]></title>
    <url>%2F2018%2F09%2F23%2FDiffie-Hellman%E5%AF%86%E9%92%A5%E5%8D%8F%E5%95%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[加密算法介绍 目前常用的加密算法主要有：哈希算法（比如MD5、SHA族、Hmac），对称加密算法（比如AES），非对称加密算法（RSA），以及Diffie-Hellman密钥协商算法等等，这几种算法都有各自的特点，适合的场景也不一样，这里只做简单的介绍，想详细了解的话，网上资料很多，可以自行查看相关的资料。 各类算法的特点： 哈希算法：正向快速，不可逆性，即加密后是很难解密出明文的。经常用于数据加密和数据校验。 对称加密算法：AES是一种常用的对称加密算法，其特点是加解密都用同一个密钥。 非对称加密算法RSA：RSA算法是一种非对称加密算法，由一个私钥和一个公钥构成的密钥对，通过私钥加密，公钥解密，或者通过公钥加密，私钥解密。其中，公钥可以公开，私钥必须保密。 Diffie-Hellman密钥协商算法：Diffie-Hellman是一种密钥协商算法（简称DH算法），DH算法基于一种数学原理，能够在双方不泄露密钥的情况下协商出一种密钥来。 场景描述 在客户端向服务器端发送数据的过程中，如果是比较重要的数据（比如密码，敏感数据等），一般需要先在客户端进行加密后再发送，服务器接收到数据后再进行解密得到原始数据。(反过来服务器返回数据给客户端也是一样的道理) 这里假设客户端和服务器端采用AES（对称加密算法）进行加解密传输的数据，AES加密算法有一个特点就是加解密都用同一个密钥（这里把该密钥称作secretKey），所以双方都通过secretKey进行数据加解密。 因此在客户端向服务器第一次传输数据的时候，客户端需要先向服务器端获取secretKey，并且保存在客户端，而这种直接向服务器获取明文secretKey的过程是很容易被第三者拦截的，也就是说这一过程是不安全的。（哈哈，除非是服务器把secretKey写到纸上，亲手偷偷地递给客户端） 因此呢，客户端向服务器获取secretKey的这一过程，也是需要进行加密的。 那么，服务器需要怎么做才能把secretKey安全的送达客户端呢？ 目前常采用的方法有：RSA 或 Diffie-Hellman 通过RSA安全传输密钥 RSA有一个公钥和一个私钥，公钥是允许公开出去的，私钥是保留的。RSA的要点在于用公钥加密的数据需要用私钥解密，用私钥加密的数据，需要用公钥解密。因此，比如这时候客户端把公钥发送给服务器，服务器利用客户端的公钥对secretKey进行加密，那么这份加密后的secretKey数据，就只有客户端的私钥能解开啦。即使第三者拿到了这份数据也解密不了，除非能获取到客户端的私钥。 所以，通过RSA的方式，服务器就能把secretKey安全的传递到客户端的手里啦。（不过，RSA也是有安全漏洞的，被称作中间人攻击，由于篇幅原因，这里就先不讲啦！大家自行百度。） 虽然使用RSA能够安全的传输secretKey密钥，但是麻烦点在于需要生成一对公钥和私钥，并且把公钥发送给对方，而且加解密速度比较慢。所以，介绍第二种：Diffie-Hellman密钥协商算法。 通过DH算法协商密钥 严格来说，DH算法其实并不是一种加密算法，因为它本身并不是用于加密的，我的理解是用于双方协商计算，即双方按照某种合约进行计算，从而计算出一种相同的结果。 原理如下： 第一步：初始化 比如现在服务器提供了两个随机公钥数字（允许公开）：pubN=10，modN=3; 客户端自己生成了一个随机私钥数字（不可公开，服务器也不知道）：cPrivN=2; 服务器端也自己生成了一个随机私钥数字（不可公开，客户端也不知道）：sPrivN=4; 第二步：客户端、服务器端分别基于相同的数学公式进行计算，计算结果称作公钥结果：pubResult 客户端进行数学计算：cPubResult = pubN cPrivN % modN = 10 2 % 3 = 2；（计算结果允许公开） 服务器进行数学计算：sPubResult = pubN sPrivN % modN = 10 4 % 3 = 1；（计算结果允许公开） 客户端和服务器端交换公钥结果，客户端得到sPubResult=1，服务器端得到cPubResult=2。 第三步：协商出一致的密钥数字:keyN（客户端和服务器端得出的结果是一致的） 客户端：cKeyN = sPubResult cPrivN % modN= 1 2 % 3 = 2； 服务器：sKeyN = cPubResult sPrivN % modN= 2 4 % 3 = 2； 到目前为止呢，双方都协商出了密钥，并且是一致的，但是呢，有没有见过密钥是number类型的？想必都没有吧，所以需要进行第四步，生成更长的密钥。 第四步：对密钥数字进行hash生成密钥串 const hash = crypto.createHash(&apos;sha256&apos;); hash.update(this.keyN.toString()); this.secretKey = hash.digest(&apos;hex&apos;);]]></content>
  </entry>
</search>
