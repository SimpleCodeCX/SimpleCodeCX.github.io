<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2019-11-13-写了一个koa-ts-cli]]></title>
    <url>%2Fblog%2F20191113%2F9d06116e.html</url>
    <content type="text"><![CDATA[写了一个koa-ts-cli koa-ts-cliA simple CLI for create koa + ts project: koats create myProject. TemplatesKoats provide three templates that are all based on ts. koa-ts-base-template This is a basic of koa project structure, integrated with ts. If you want to custom the structure of the project, this template is for you koa-ts-full-template This is a full project structure, integrated with ts.This project has been configured with a mysql database, support different environment(local,dev,prod) configuration, some custom koa middleware have configured, and it has been the definition of a unified api response format. koa-ts-full-stack-template This is a full-stack project structure based on koa-ts-full-template. It contains three parts: client: This directory is the front-end code. server: This directory is the back-end code. common: This directory is the common code for front-end and back-end. This three template has the following three common features. ✓ koa v2 ✓ Typescript ✓ Jest ✓ APIDOC ✓ Docker ✓ Eslint ✓ Husky Installation1npm i -g koa-ts-cli Create Project12345koats create myProject# Choose your favorite template.cd myProjectnpm install In development mode12cd myProjectnpm run dev NOTE: If you choose koa-ts-full-template or koa-ts-full-stack-template, you need to do some configuration. In porduction mode123npm run buildcd myProject/distnpm run prod NOTE: If you choose koa-ts-full-template or koa-ts-full-stack-template, you need to do some configuration. Run in docker12345cd myProjectnpm installnpm run buildsudo docker build -t koa-ts-api-server .sudo docker run -it --name koa-ts-api-server -p 8080:8080 koa-ts-api-server Test12cd myProjectnpm run test]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 == 和 ===的区别]]></title>
    <url>%2Fblog%2F20190825%2F2c3ab5b6.html</url>
    <content type="text"><![CDATA[== 的判断规则1、同类型比较，进行 === 比较2、如果两个值类型不同，则根据如下规则进行类型转换再进行比较： 1）如果一个是字符换，一个是数字，则将字符串转换成数字，再进行值比较 2）如果任一值是 true，把它转换成 1 再比较；如果任一值是 false，把它转换成 0 再比较。 3）如果一个是对象，另一个是基础类型(数值或字符串)，则把对象转换成基础类型的值再比较。 对象转换成基础类型，利用它的 toString 或者 valueOf 方法。 4）高级类型与高级类型，进行指针地址比较 5）如果一个是null，一个是undefined，那么相等 一、=== 的判断规则1、如果类型不同，则不相等 2、如果两个都是数值，并且是同一个值，则相等。但例外的是 NaN !== NaN（可以通过 isNaN() 来判断是否为 NaN） 3、如果两个都是字符串，每个位置的字符都一样，那么相等，否则不相等 4、如果两个值都为true，或者都为false，那么相等 5、如果两个值都引用同一个对象或函数，那么相等 6、如果两个值都是null，或者都是undefined，那么相等 二、== 的判断规则1、同类型比较，进行 === 比较 2、如果两个值类型不同，则根据如下规则进行类型转换再进行比较： 1）如果一个是字符换，一个是数字，则将字符串转换成数字，再进行值比较 2）如果任一值是 true，把它转换成 1 再比较；如果任一值是 false，把它转换成 0 再比较。 3）如果一个是对象，另一个是基础类型(数值或字符串)，则把对象转换成基础类型的值再比较。 对象转换成基础类型，利用它的 toString 或者 valueOf 方法。 4）高级类型与高级类型，进行指针地址比较 5）如果一个是null，一个是undefined，那么相等 三、关于类型转换1、any -&gt; boolean number -&gt; boolean 除了 0, -0, NaN 都为 true string -&gt; boolean 除了空串，都为true undefined、null -&gt; boolean 为 false 引用类型 -&gt; boolean 都为 true, [] -&gt; true, {} -&gt; true 2、any -&gt; string number -&gt; string 5 -&gt; &apos;5&apos; boolean -&gt; string true -&gt; &apos;true&apos; 数组 -&gt; string [1,2] -&gt; &apos;1,2&apos; 对象 -&gt; string {...} -&gt; &apos;[object,Object]&apos; 2、any -&gt; number string -&gt; number &apos;&apos; -&gt; 0, &apos;1&apos; -&gt; 1, &apos;a&apos; -&gt; NaN boolean -&gt; number true -&gt; 1, false -&gt; 0 数组 -&gt; number [] -&gt; 0, [1] -&gt; 1, [1,2] -&gt; NaN (空数组转为0,存在一个元素且元素为数字转为数字,其他情况转为NaN) null -&gt; number 0 undefined -&gt; number NaN 除了数组的引用类型 -&gt; number 都为NaN, {} -&gt; NaN 1、any -&gt; boolean 123456789101112131415// number -&gt; booleanconsole.log(Boolean(0)); // falseconsole.log(Boolean(-0)); // falseconsole.log(Boolean(NaN)); // falseconsole.log(Boolean(1111)); // true// string -&gt; booleanconsole.log(Boolean('')); // falseconsole.log(Boolean('11')); // true// undefined、null -&gt; booleanconsole.log(Boolean(undefined)); // falseconsole.log(Boolean(null)); // false// 引用类型 -&gt; booleanconsole.log(Boolean([])); // trueconsole.log(Boolean(&#123;&#125;)); // trueconsole.log(Boolean([111])); // true 2、any -&gt; string 12345678910111213// number -&gt; stringconsole.log(String(0)); // '0'console.log(String(111)); // '111'// boolean -&gt; stringconsole.log(String(true)); // 'true'console.log(String(false)); // 'false'// 数组 -&gt; stringconsole.log(String([])); // ''console.log(String([1, 2])); // '1,2'console.log(String(['1', '2', '3'])); // '1,2,3'// 对象 -&gt; stringconsole.log(String(&#123;&#125;)); // '[object Object]'console.log(String(&#123; a: 'a' &#125;)); // '[object Object]' 3、any -&gt; number 123456789101112131415161718// string -&gt; numberconsole.log(Number('')); // 0console.log(Number('11')); // 11console.log(Number('a')); // NaN// boolean -&gt; numberconsole.log(Number(true)); // 1console.log(Number(false)); // 0// 数组 -&gt; numberconsole.log(Number([])); // 0console.log(Number([111])); // 111console.log(Number([111, 222])); // NaNconsole.log(Number(['a'])); // NaN// undefined、null -&gt; numberconsole.log(Number(undefined)); // NaNconsole.log(Number(null)); // 0// 除了数组的引用类型 -&gt; numberconsole.log(Number(&#123;&#125;)); // NaNconsole.log(Number(function () &#123; &#125;)); // NaN 四、== 举例 1、如果一个是字符串，一个是数值，把字符串转换成数值再进行比较。 12console.log('111' == 111); // trueconsole.log('a' == 1); // false 2、如果一个是 null、一个是 undefined，那么[相等]。 1console.log(null == undefined); // true 3、如果任一值是 true，把它转换成 1 再比较；如果任一值是 false，把它转换成 0 再比较。 12console.log(true == 1); // trueconsole.log(false == 0); // true 4、高级类型与高级类型，进行指针地址比较 123456789console.log(&#123;&#125; == &#123;&#125;); // falseconst obj1 = &#123;&#125;;const obj2 = obj1;console.log(obj2 == obj1); // trueconsole.log([] == []); // falseconst arr1 = [];const arr2 = arr1;console.log(arr1 == arr1); // true 5、如果一个是对象，另一个是基础类型(数值或字符串)，则把对象转换成基础类型的值再比较。对象转换成基础类型，利用它的 toString 或者 valueOf 方法。 123456789101112131415161718192021222324252627282930// 等号右边:// ![] -&gt; false -&gt; 0 (说明: 所有引用类型转化为 boolean 都为 true, 因此 [] -&gt; true, ![] -&gt; false, // 如果任一值是 true, 把它转换成 1 再比较。因此 false -&gt; 0 )// 等号左边:// [] -&gt; 0 (说明:由于等号右边是number类型, 因此需要转化为number类型)console.log([] == ![]); // true// 等号右边:// !&#123;&#125; -&gt; false -&gt; 0 (说明: 所有引用类型转化为 boolean 都为 true, 因此 &#123;&#125; -&gt; true, !&#123;&#125; -&gt; false, // 如果任一值是 true, 把它转换成 1 再比较。因此 false -&gt; 0 )// 等号左边:// &#123;&#125; -&gt; NaN (说明:由于等号右边是number类型, 因此需要转化为number类型)console.log(&#123;&#125; == !&#123;&#125;); // false// 等号右边: 字符串: '111,222' // 等号左边: [111, 222] -&gt; '111,222' (说明:由于等号右边是 string 类型, 因此需要转化为 string 类型)console.log([111, 222] == '111,222') // true// 等号右边: 数字: 111 // 等号左边: [111, 222] -&gt; NaN (说明:由于等号右边是 number 类型, 因此需要转化为 number 类型)console.log([111, 222] == 111) // false// 等号右边: 字符串: '111' // 等号左边: [111, 222] -&gt; '[object Object]' (说明:由于等号右边是 string 类型, 因此需要转化为 string 类型)console.log(&#123;&#125; == '111') // falseconsole.log(&#123;&#125; == '[object Object]') // true]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动定时备份 mysql 数据库 的 shell 脚本]]></title>
    <url>%2Fblog%2F20190414%2F9ad25d4f.html</url>
    <content type="text"><![CDATA[通过 mysqldump 和 crontab 实现定时备份 mysql 数据库 一、前颜通过 mysqldump 和 crontab 实现定时备份 mysql 数据库 二、备份数据库的脚本如下backMysql.sh12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#!/bin/bashPATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbinexport PATH#数据库ipDBHOST='xxx.xxx.xxx.xxx' // your db host#数据库用户名DBUSER='admin' // 数据库用户名#数据库用密码DBPASSWD='password' // 数据库用户名对应的密码#需要备份的数据库，多个数据库用空格分开DBNAME='dbname' // 数据库名#备份时间backtime=`date +%Y-%m-%d_%H%M%S`#备份路径（当前目录）BACKPATH=$(dirname $(readlink -f $0))echo $BACKPATH#日志备份路径LOGPATH="$&#123;BACKPATH&#125;/log"#数据备份路径DBPATH="$&#123;BACKPATH&#125;/db"#创建备份目录[ ! -d "$&#123;LOGPATH&#125;" ] &amp;&amp; mkdir -p "$&#123;LOGPATH&#125;"[ ! -d "$&#123;DBPATH&#125;" ] &amp;&amp; mkdir -p "$&#123;DBPATH&#125;"#日志记录头部echo "备份时间为$&#123;backtime&#125;,备份数据库表 $&#123;DBNAME&#125; 开始" &gt;&gt; $&#123;LOGPATH&#125;/mysqlback.log#正式备份数据库for table in $DBNAME; dosource=`mysqldump -u $&#123;DBUSER&#125; -h$&#123;DBHOST&#125; -p$&#123;DBPASSWD&#125; $&#123;table&#125;&gt; $&#123;LOGPATH&#125;/$&#123;backtime&#125;.sql` 2&gt;&gt; $&#123;LOGPATH&#125;/mysqlback.log;#备份成功以下操作 $?获取上一个命令的操作结果，0代表成功if [ "$?" == 0 ];thencd $&#123;LOGPATH&#125;#为节约硬盘空间，将数据库压缩tar -czf $&#123;DBPATH&#125;/$&#123;table&#125;$&#123;backtime&#125;.tar.gz ./$&#123;backtime&#125;.sql &gt; /dev/null#删除原始文件，只留压缩后文件rm -f $&#123;LOGPATH&#125;/$&#123;backtime&#125;.sql#删除七天前备份，也就是只保存7天内的备份find $DBPATH -name "*.tar.gz" -type f -mtime +7 -exec rm -rf &#123;&#125; \; &gt; /dev/null 2&gt;&amp;1echo "数据库表 $&#123;DBNAME&#125; 备份成功!!" &gt;&gt; $&#123;LOGPATH&#125;/mysqlback.logelse#备份失败则进行以下操作echo "数据库表 $&#123;DBNAME&#125; 备份失败!!" &gt;&gt; $&#123;LOGPATH&#125;/mysqlback.logfidone 三、定时备份通过 crontab 定时执行 backMysql.sh 脚本，配置每个小时备份一次，步骤如下： 1) 运行 crontab -e2) 输入 0 /home/admin/dbBackup/backMysql.sh 以上实现每个小时整点备份一次，关于 crontab 的用法，可以查看相关资料]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于nodejs koa2的解决跨域中间件设计]]></title>
    <url>%2Fblog%2F20190414%2Fc9d7326.html</url>
    <content type="text"><![CDATA[解决浏览器跨域问题的方法有很多种1) 通过后端设置 http Access-Control-* 相关响应头2) 通过 Jsonp3) 通过 nginx 反向代理 关于这三种解决跨域方法的介绍可以看我的另外一篇文章： 如何解决前端跨域问题 本文主要讲基于 nodejs koa2 实现第一种跨域方案，并设计成 koa2 中间件 一、解决浏览器跨域问题的方法有很多种1) 通过后端设置 http Access-Control-* 相关响应头2) 通过 Jsonp3) 通过 nginx 反向代理 关于这三种解决跨域方法的介绍可以看我的另外一篇文章： 如何解决前端跨域问题 本文主要讲基于 nodejs koa2 实现第一种跨域方案，并设计成 koa2 中间件 二、跨域中间件实现的功能1) 支持跨域 cookie2) 支持指定的跨域 http 请求头，比如 accesstoken 等2) 对预检结果进行缓存,缓存时间设置为1天（即86400秒）3) 当http method 为 OPTIONS时，为预检时，此时直接返回空响应体,对应的 http 状态码为 204 三、koa-cors 中间件代码koa-cors.js 123456789101112131415161718192021222324252627282930const URL = require('url');/** * 关键点： * 1、如果需要支持 cookies, * Access-Control-Allow-Origin 不能设置为 *, * 并且 Access-Control-Allow-Credentials 需要设置为 true * (注意前端请求需要设置 withCredentials = true) * 2、当 method = OPTIONS 时, 属于预检(复杂请求), 当为预检时, 可以直接返回空响应体, 对应的 http 状态码为 204 * 3、通过 Access-Control-Max-Age 可以设置预检结果的缓存, 单位(秒) * 4、通过 Access-Control-Allow-Headers 设置需要支持的跨域请求头 * 5、通过 Access-Control-Allow-Methods 设置需要支持的跨域请求方法 */module.exports = async function (ctx, next) &#123; const origin = URL.parse(ctx.get('origin') || ctx.get('referer') || ''); if (origin.protocol &amp;&amp; origin.host) &#123; ctx.set('Access-Control-Allow-Origin', `$&#123;origin.protocol&#125;//$&#123;origin.host&#125;`); ctx.set('Access-Control-Allow-Methods', 'POST, GET, OPTIONS, DELETE, PUT'); ctx.set('Access-Control-Allow-Headers', 'X-Requested-With, User-Agent, Referer, Content-Type, Cache-Control,accesstoken'); ctx.set('Access-Control-Max-Age', '86400'); ctx.set('Access-Control-Allow-Credentials', 'true'); &#125; if (ctx.method !== 'OPTIONS') &#123; // 如果请求类型为非预检请求，则进入下一个中间件（包括路由中间件等） await next(); &#125; else &#123; // 当为预检时，直接返回204,代表空响应体 ctx.body = ''; ctx.status = 204; &#125;&#125;; Access-Control-Allow-Origin：Access-Control-Allow-Origin 可以设置为 * 通配符，也可以指定具体的地址比如：https://developer.mozilla.org。 当把 Access-Control-Allow-Origin 设置为 * 时，表示允许所有资源访问，但是此时不支持带 credentials 的请求， 因此为了实现允许所有资源访问且支持带 credentials 的请求，将其设置为 ${origin.protocol}//${origin.host}（即动态获取访问者地址） Access-Control-Allow-Headers默认支持 Accept、Accept-Language、Content-Language、Content-Type (只支持 application/x-www-form-urlencoded, multipart/form-data, or text/plain)。 如果请求头需要添加自定义的 http header 比如 access_token ,那么需要将 access_token 添加进数组中 Access-Control-Allow-Credentials简单的理解就是支持 cookie Access-Control-Max-Age设置 OPTIONS 请求(预检请求)的返回结果的缓存时间, 单位s 关于 OPTIONS 请求：在非简单请求且跨域的情况下，浏览器会发起 options 预检请求。可以参考我的另一篇文章：关于浏览器预检请求 四、使用方法app.js12const cors = require('./middlewares/koa-cors');app.use(cors); // 跨域 五、github 代码https://github.com/SimpleCodeCX/myCode/tree/master/nodejs/koa2/cors-demo 参考文档： Access-Control-Allow-Headers credentials Access-Control-Allow-Credentials Access-Control-Max-Age]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于浏览器预检请求]]></title>
    <url>%2Fblog%2F20190414%2F76328cc8.html</url>
    <content type="text"><![CDATA[在非简单请求且跨域的情况下，浏览器会发起options预检请求。 浏览器在什么情况下会发起options预检请求？在非简单请求且跨域的情况下，浏览器会发起options预检请求。 关于简单请求和复杂请求：1 简单请求 简单请求需满足以下两个条件1) 请求方法是以下三种方法之一： HEAD GET POST2) HTTP 的头信息不超出以下几种字段 Accept Accept-Language Content-Language Last-Event-ID Content-Type: 只限于 (application/x-www-form-urlencoded、multipart/form-data、text/plain) 2 复杂请求 非简单请求即是复杂请求 常见的复杂请求有： 1) 请求方法为 PUT 或 DELETE 2) Content-Type 字段类型为 application/json 3) 添加额外的http header 比如access_token 在跨域的情况下，非简单请求会先发起一次空body的OPTIONS请求，称为”预检”请求，用于向服务器请求权限信息，等预检请求被成功响应后，才发起真正的http请求。 浏览器的预检请求结果可以通过设置Access-Control-Max-Age进行缓存 如何解决跨域问题请看我的另一篇文章: 如何解决前端跨域问题]]></content>
      <categories>
        <category>前端跨域</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4系列实践笔记]]></title>
    <url>%2Fblog%2F20190325%2F720ca7f0.html</url>
    <content type="text"><![CDATA[webpack 是目前 javascript 主流的工程自动构建工具，目前 Vue，React 以及 Angular 等项目脚手架都是基于 webpack 进行构建的。本系列代码放在 github 上: webpack4系列实践代码 本系列代码放在 github 上: webpack4系列实践代码如果本系列实践教程对你有帮助,欢迎给个 github star 哦! 1.webpack 是什么？webpack 是目前 javascript 主流的工程自动构建工具，目前 Vue，React 以及 Angular 等项目脚手架都是基于 webpack 进行构建的。 webpack 官方中文文档：https://www.webpackjs.com/concepts/ webpack 官方英文文档：https://webpack.js.org/concepts 2.webpack 需要安装的环境 webpack 需要安装的环境有： webpack webpack-cli 安装的方式有两种： 项目本地安装( npm install webpack webpack-cli ) 运行方法: 1.\node_modules\.bin\webpack .\index.js 全局安装( npm install webpack webpack-cli -g ) 运行方法: 1webpack .\index.js 不理解本地安装和全局安装? 撸一遍npm的文档? https://www.npmjs.cn/ 为了避免每个demo都在本地安装一遍 webpack 和 webpack-cli ，这里推荐使用全局安装的方式。 注意：有一些 webpack plugin 是依赖于 webpack 或 webpack-cli 的，比如 mini-css-extract-plugin, html-webpack-plugin 或 webpack-dev-server 等 ,这种情况需要本地安装 webpack: npm install webpack ,但编译环境依然可以使用全局 webpack 命令来进行编译打包（前提是你的本地 webpack 和全局的 webpack 版本兼容）。 3.我的webpack版本webpack: v4.29.5 webpack-cli: 3.2.3 本 webpack4 系列的实践 demo 都是基于此版本进行的 4.关于安装webpack3.1 首先安装 nodejs ,安装成功后，会自带 npm 管理器 3.2 安装 webpack1npm install -g webpack webpack-cli 3.2 查看当前 webpack 版本号1webpack -v 5.demo listdemo01: 最简单的 webpack 零配置实践 demo02: 使用 webpack.config.js 配置文件 demo03: webpack 默认支持各种模块化规范 demo04: webpack + babel7 demo05: webpack + typescript demo06: webpack + babel7 + typescript demo07: 自动生成 Html 文件 demo08: 关于 SplitChunksPlugin demo09: 使用 SplitChunksPlugin 分离第三方依赖包以及异步包 demo10: 关于 Tree Shaking demo11: webpack 处理 css demo12: webpack 处理 scss demo13: webpack通过postcss-loader加工css和scss demo14: mini-css-extract-plugin + SplitChunksPlugin 处理 css 和 scss demo15: webpack 处理图片 demo16: webpack 处理字体 demo17: demo17 clean-webpack-plugin (清除模式) demo18: webpack-dev-server (开发模式) demo19: webpack 开发模式和生产模式 6.源码地址https://github.com/SimpleCodeCX/simple-webpack-demos 7.关于作者 GitHub: https://github.com/SimpleCodeCX 个人博客: http://www.cxdsimple.com 个人线上简历: http://www.cxdsimple.com/cv/ Email: 248200851@qq.com]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4实践笔记19-webpack开发模式和生产模式]]></title>
    <url>%2Fblog%2F20190325%2Fb59b574f.html</url>
    <content type="text"><![CDATA[开发环境和生产环境的构建目标是有很大的不同的。在开发环境中，为了便于代码调试以及实现浏览器实时更新,我们需要开启 source map 和 localhost server。而在生成环境中,为了实现缓存优化以及改善加载时间,我们的目标转向于打包成更小的 bundle 或 chunk,分离第三方包以及开启更轻量级的 source map 以及更优化的资源。因此开发环境和生产环境需要单独配置 webpack。 本系列代码放在 github 上: webpack4系列实践代码如果本系列实践教程对你有帮助,欢迎给个 github star 哦! 1.开发环境和生产环境的 webpack 配置开发环境和生产环境的构建目标是有很大的不同的。 在开发环境中，为了便于代码调试以及实现浏览器实时更新,我们需要开启 source map 和 localhost server。 而在生成环境中,为了实现缓存优化以及改善加载时间,我们的目标转向于打包成更小的 bundle 或 chunk,分离第三方包以及开启更轻量级的 source map 以及更优化的资源。 因此开发环境和生产环境需要单独配置 webpack。 2.定个需求假设项目打包需求如下: 公共部分: 自动生成html、并解析css、js文件 (html-webpack-plugin) 处理scss,以及自动添加css前缀 ( postcss-loader sass-loader css-loader style-loader) 处理图片和字体,小于 20k 转化为base64字符串,大于20k则通过url引用 (url-loader file-loader) 处理typescript (ts-loader) 在开发环境下: 开启 source map 开启 devServer 在生产环境下: 压缩代码 将css分离成单独的css文件,并进行压缩 mini-css-extract-plugin 将第三方依赖包分离成单独的 chunk (SplitChunksPlugin) 将异步包分离成单独的 chunk 3.webpack配置文件根据以上情况，我们需要定义三个webpack配置文件,分别是: webpack.base.conf.js 用来配置开发模式和生产模式的wenpack公共配置 webpack.dev.conf.js 用来专门配置开发模式所需的webpack配置 webpack.prod.conf.js 用来专门配置生产模式所需的webpack配置 4.目录机构1234567891011121314151617181920212223242526--demo19 --build -config.js -webpack.base.conf.js //公共配置 -webpack.dev.conf.js //开发环境 -webpack.prod.conf.js //生产环境 --src --app -app.ts --assets --fonts // 字体相关 -icomoon.css -icomoon.eot -icomoon.svg -icomoon.ttf -icomoon.woff --images // 图片相关 -1.png //18.6KB -2.png //12.1KB -3.png //14.9KB -me.jpg //2.58MB --styles -app.scss -index.html -postcss.config.js // 处理 css 前缀 -tsconfig.json // 处理 ts 代码放在github上 5.安装相关依赖12345678910npm install -D css-loader style-loader node-sass sass-loader // 处理scssnpm install -D postcss postcss-loader autoprefixer // 处理css前缀npm install -D file-loader url-loader // 处理字体和图片npm install -D ts-loader typescript // 处理tsnpm install -D html-webpack-plugin clean-webpack-plugin // 自动生成html文件以及清除dist目录npm install -D webpack-dev-server // devServernpm install -D mini-css-extract-plugin // 分离css为单独的文件npm install -D optimize-css-assets-webpack-plugin uglifyjs-webpack-plugin // 压缩css和js文件npm install -D webpack-merge // 合并webpack配置: base + dev 或 base + prodnpm install -D webpack webpack-cli 6.webpack配置文件如下webpack.base.conf.js（开发和生产模式的公共配置）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556'use strict'const path = require("path");const isDev = /^dev/.test(process.env.npm_lifecycle_event);const config = require('./config');const CleanWebpackPlugin = require("clean-webpack-plugin");const HtmlWebpackPlugin = require("html-webpack-plugin");module.exports = &#123; mode: isDev ? "development" : "production", // 开发模式 entry: &#123; app: "./src/app/app.ts" &#125;, output: &#123; publicPath: isDev ? config.dev.publicPath : config.prod.publicPath, // 打包后资源文件的引用会基于此路径 path: path.resolve(__dirname, "..", "dist"), // 打包后的输出目录 filename: isDev ? config.dev.filename : config.prod.filename,// 在development模式下,id为name chunkFilename: isDev ? config.dev.chunkFilename : config.prod.chunkFilename &#125;, resolve: &#123; extensions: ['.ts', '.js'] &#125;, module: &#123; rules: [ &#123; test: /\.(ttf|eot|svg|woff|woff2)$/, use: 'url-loader' &#125;, &#123; test: /\.(jpg|png|gif|bmp|jpeg)$/, use: [ &#123; loader: 'url-loader', options: &#123; limit: 20000, // size &lt;= 20KB name: '[name].[hash].[ext]', // 属于file-loader的属性 publicPath: "imgs/", // 属于file-loader的属性 outputPath: "imgs/" // 属于file-loader的属性 &#125; &#125; ] &#125;, &#123; test: /\.ts?$/, use: 'ts-loader', exclude: /node_modules/ &#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; // 自动生成html,并且自动导入所有依赖同步包 filename: "index.html", template: path.resolve(__dirname, "../src", "index.html"), minify: &#123; collapseWhitespace: true // 压缩 &#125; &#125;), new CleanWebpackPlugin() ]&#125;; webpack.dev.conf.js （开发模式所需配置）12345678910111213141516171819202122232425262728293031323334'use strict'const path = require('path');const merge = require('webpack-merge')const baseWebpackConfig = require('./webpack.base.conf')const devWebpackConfig = merge(baseWebpackConfig, &#123; devtool: "source-map", devServer: &#123; contentBase: path.join(__dirname, "../dist/"), port: 8000, hot: false, overlay: true, historyApiFallback: &#123; rewrites: [&#123; from: /.*/, to: "/index.html" &#125;] &#125; &#125;, module: &#123; rules: [ &#123; test: /\.(sa|sc|c)ss$/, use: [ "style-loader", "css-loader", // 将 CSS 转化成 js 模块 &#123; loader: 'postcss-loader' // 配置在postcss.config.js &#125;, "sass-loader" // 将 Sass/Scss 编译成 CSS ] &#125; ] &#125;, plugins: []&#125;);module.exports = devWebpackConfig; webpack.prod.conf.js （生产模式所需配置）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859'use strict'const merge = require('webpack-merge');const UglifyJsPlugin = require("uglifyjs-webpack-plugin");const MiniCssExtractPlugin = require("mini-css-extract-plugin");const OptimizeCSSAssetsPlugin = require("optimize-css-assets-webpack-plugin");const baseWebpackConfig = require('./webpack.base.conf')const prodWebpackConfig = merge(baseWebpackConfig, &#123; module: &#123; rules: [ &#123; test: /\.(sa|sc|c)ss$/, use: [ MiniCssExtractPlugin.loader, // 将css提取为单独的文件 "css-loader", // 将 CSS 转化成 js 模块 &#123; loader: 'postcss-loader',// 配置在postcss.config.js &#125;, "sass-loader" // 将 Sass/Scss 编译成 CSS ] &#125; ] &#125;, optimization: &#123; runtimeChunk: "single", // webpack运行时代码单独提取为一个包 minimizer: [ new UglifyJsPlugin(&#123; cache: true, parallel: true, sourceMap: false // set to true if you want JS source maps &#125;), new OptimizeCSSAssetsPlugin(&#123;&#125;) ], splitChunks: &#123; cacheGroups: &#123; async: &#123; chunks: "async", maxInitialRequests: 3, // 设置最大的请求数 automaticNameDelimiter: '~', priority: 9 &#125;, vendors: &#123; chunks: "all", // 使用 all 模式 test: /[\\/]node_modules[\\/]/, // 匹配 node_modules 下的模块 name: "vendors", // 包命名，最终的命名要结合 output 的 chunkFilename priority: 10 // 设置优先级 &#125; &#125; &#125; &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: "[id].[name].[chunkhash:8].css", chunkFilename: "[id].[name].[chunkhash:8].css" &#125;) ]&#125;);module.exports = prodWebpackConfig; 5.配置 npm scripts 命令在 package.json 中添加如下 npm scripts1234"scripts": &#123; "dev": "webpack-dev-server --open --inline --progress --config build/webpack.dev.conf.js", "prod": "webpack --config build/webpack.prod.conf.js"&#125;, 6.执行命令 执行如下命令，开启开发调试模式,自动打开浏览器,当修改代码时,浏览器自动刷新,便于开发和调试。1npm run dev 执行如下命令,webpack将以production模式进行打包,实现代码压缩,分离第三方模块以及css为单独的chunk,这样有利于对单独的包进行缓存优化。1npm run prod 7.源码地址demo 代码地址: https://github.com/SimpleCodeCX/simple-webpack-demos/tree/master/demo19-dev-prod仓库代码地址(及目录): https://github.com/SimpleCodeCX/simple-webpack-demos]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4实践笔记18 webpack-dev-server (开发模式)]]></title>
    <url>%2Fblog%2F20190311%2Ff1f1f195.html</url>
    <content type="text"><![CDATA[development 模式:在开发环境中，我们希望能够更加方便的进行开发以及调试代码，当项目运行起来后，可以自动打开浏览器，webpack 能够通过监听代码的修改，自动重新编译打包，并且实时刷新浏览器。production 模式:在生产模式中，我们希望能够得到一个更小的 bundle，更轻量的 source &gt;map，从而改善加载时间。如果没有设置 mode ，webpack 默认以 production 模式进行打包。 本系列代码放在 github 上: webpack4系列实践代码如果本系列实践教程对你有帮助,欢迎给个 github star 哦! 1.development vs productiondevelopment 模式: 在开发环境中，我们希望能够更加方便的进行开发以及调试代码，当项目运行起来后，可以自动打开浏览器，webpack 能够通过监听代码的修改，自动重新编译打包，并且实时刷新浏览器。 production 模式: 在生产模式中，我们希望能够得到一个更小的 bundle，更轻量的 source &gt;map，从而改善加载时间。 如果没有设置 mode ，webpack 默认以 production 模式进行打包。 2.webpack-dev-serverwebpack-dev-server 是 webpack 官方提供的一个小型 Express 服务器。通过配置它可以在开发模式下为 webpack 打包生成的静态资源文件启动一个 web 服务器，并检测代码的变化进行实时更新。 注意：webpack-dev-server只能工作于 development 模式。 webpack4提供了一个 devServer 的选项，来配置 webpack-dev-server。 devServer 的配置项挺多的，详见文档：https://www.webpackjs.com/configuration/dev-server/ contentBase: 设置静态资源的路径，默认是当前工作目录。 hot: 设置热更新功能，实现不刷新浏览器就能对修改到的模块进行热更新。 open： devServer 自动打开浏览器 overlay: 配置当 webpack 编译警告或出错时，是否在浏览器显示 123456overlay: true // 显示错误或overlay: &#123; warnings: true, // 显示警告 errors: true // 显示错误&#125; port: 指定要监听请求的端口号 proxy: devServer 是一个基于 express 的后端服务，在后端中是没有跨域的限制的（因为跨域是浏览器的行为），因此，通过这个代理，浏览器就不会出现跨域的问题了。比如通过如下配置把 /api 代理到 http://xxx.xxx.xxx.xxx/api 123proxy: &#123; &quot;/api&quot;: &quot;http://xxx.xxx.xxx.xxx/api&quot;&#125; historyApiFallback: 当使用 HTML5 History API 时，默认情况下任意的 404 响应都被替换为 index.html。 可以通过如下修改配置 1234567historyApiFallback: &#123; rewrites: [ &#123; from: /^\/$/, to: '/views/landing.html' &#125;, &#123; from: /^\/subpage/, to: '/views/subpage.html' &#125;, &#123; from: /./, to: '/views/404.html' &#125; ]&#125; 3.安装相关依赖 注意: webpack-dev-server 依赖于 webpack 和 webpack-cli，所以需要在本地安装 webpack 和 webpack-cli。 12345npm install -D webpack-dev-servernpm install -D webpack webpack-clinpm install -D css-loader url-loader file-loader npm install -D mini-css-extract-plugin npm install -D html-webpack-plugin clean-webpack-plugin 4.目录结构123456789101112131415// `--` 代表目录， `-` 代表文件 --demo14 font --src --assets --fonts -icomoon.css -icomoon.eot //3KB -icomoon.svg //5KB -icomoon.ttf //3KB -icomoon.woff //3KB --styles -app.css -app.js -index.html -webpack.config.js src/assets/fonts/icomoon.css12345678910111213141516171819202122232425262728293031323334353637@font-face &#123; font-family: "icomoon"; src: url("./icomoon.eot?nn7hff"); src: url("./icomoon.eot?nn7hff#iefix") format("embedded-opentype"), url("./icomoon.ttf?nn7hff") format("truetype"), url("./icomoon.woff?nn7hff") format("woff"), url("./icomoon.svg?nn7hff#icomoon") format("svg"); font-weight: normal; font-style: normal;&#125;[class^="icon-"],[class*=" icon-"] &#123; /* use !important to prevent issues with browser extensions that change fonts */ font-family: "icomoon" !important; speak: none; font-style: normal; font-weight: normal; font-variant: normal; text-transform: none; line-height: 1; /* Better Font Rendering =========== */ -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125;.icon-wechat:before &#123; content: "\e900"; color: #7bb32e;&#125;.icon-github:before &#123; content: "\e902";&#125;.icon-envelop:before &#123; content: "\e945";&#125; src/assets/styles/app.css1234567891011.icons-box &#123; width: 500px; height: 100px; margin: auto; margin-top: 180px;&#125;.icons-box i &#123; font-size: 100px; margin-left: 20px;&#125; src/app.js 12import "./assets/fonts/icomoon.css";import "./assets/styles/app.css"; 5.编写webpack配置文件webpack.config.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const path = require("path");const MiniCssExtractPlugin = require("mini-css-extract-plugin");const HtmlWebpackPlugin = require("html-webpack-plugin");const CleanWebpackPlugin = require("clean-webpack-plugin");module.exports = &#123; mode: "development", // 开发模式 entry: &#123; app: "./src/app.js" &#125;, output: &#123; publicPath: '/', // 打包后资源文件的引用会基于此路径 path: path.resolve(__dirname, "dist"), // 打包后的输出目录 filename: "[id].[name].[chunkhash:8].bundle.js", // 在development模式下,id为name chunkFilename: "[id].[name].[chunkhash:8].chunk.js" &#125;, devtool: "source-map", // devServer: &#123; contentBase: path.join(__dirname, "dist"), port: 8000, hot: false, overlay: true, historyApiFallback: &#123; rewrites: [&#123; from: /.*/, to: "/index.html" &#125;] &#125; &#125;, module: &#123; rules: [ &#123; test: /\.css$/, use: [ MiniCssExtractPlugin.loader, "css-loader" ] &#125;, &#123; test: /\.(eot|woff2?|ttf|svg)$/, use: [ &#123; loader: "url-loader", options: &#123; name: "[name]-[hash:5].min.[ext]", limit: 3000, publicPath: "fonts/", outputPath: "fonts/" &#125; &#125; ] &#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; // 自动生成html,并且自动导入所有依赖同步包 filename: "index.html", template: "./index.html", minify: &#123; // collapseWhitespace: true // 压缩 &#125; &#125;), new MiniCssExtractPlugin(&#123; filename: "[id].[name].[chunkhash:8].css", chunkFilename: "[id].[name].[chunkhash:8].css" &#125;), new CleanWebpackPlugin(["dist"]) ]&#125;; 6.修改package.jsonpackage.json 添加 script 脚本123"scripts": &#123; "dev": "webpack-dev-server --open"&#125;, 7.执行打包命令1npm run dev 运行成功后，会自动打开浏览器并显示 index.html 页面，修改 css 或 js 代码后，浏览器会自动刷新。 8.源码地址demo 代码地址: https://github.com/SimpleCodeCX/simple-webpack-demos/tree/master/demo18-devServer仓库代码地址(及目录): https://github.com/SimpleCodeCX/simple-webpack-demos]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4实践笔记17 clean-webpack-plugin (清除模式)]]></title>
    <url>%2Fblog%2F20190311%2F8515384d.html</url>
    <content type="text"><![CDATA[在之前的 demo 中，webpack 打包后会在根目录下自动创建 dist 目录，并且把生成的文件输出到 dist 下。当配置的输出包名含有 [hash] 时，hash值会随着文件内容的改变而改变。因此，我们需要在下一次 webpack 打包输出之前，把 dist 目录清空。clean-webpack-plugin 插件就能帮你做到。 本系列代码放在 github 上: webpack4系列实践代码如果本系列实践教程对你有帮助,欢迎给个 github star 哦! 1.为什么需要自动清除 dist 文件夹在之前的 demo 中，webpack 打包后会在根目录下自动创建 dist 目录，并且把生成的文件输出到 dist 下。 当配置的输出包名含有 [hash] 时，hash值会随着文件内容的改变而改变。 因此，我们需要在下一次 webpack 打包输出之前，把 dist 目录清空。 clean-webpack-plugin 插件就能帮你做到。 2.clean-webpack-pluginclean-webpack-plugin 可以实现 webpack 每次打包之前，清空指定目录。 注意: clean-webpack-plugin 插件应该放在 plugins 的最后，因为 webpack 的插件执行顺序是从后往前执行的。比如:12345plugins: [ new HtmlWebpackPlugin(), new MiniCssExtractPlugin(), new CleanWebpackPlugin(["dist"]) // 需放在最后一个] 3.安装相关依赖123npm install -D clean-webpack-pluginnpm install -D css-loader style-loadernpm install -D html-webpack-plugin webpack 4.目录机构1234567// `--` 代表目录， `-` 代表文件 --demo16 clean --src -app.js -style.css -index.html -webpack.config.js src/style.css123body &#123; background-color: red;&#125; src/app.js1const css = import('./style.css'); 5.编写webpack配置文件webpack.config.js 1234567891011121314151617181920212223242526272829303132333435363738const path = require("path");const HtmlWebpackPlugin = require("html-webpack-plugin");const CleanWebpackPlugin = require("clean-webpack-plugin");module.exports = &#123; entry: &#123; app: "./src/app.js" &#125;, output: &#123; publicPath: __dirname + "/dist/", // 打包后资源文件的引用会基于此路径 path: path.resolve(__dirname, "dist"), // 打包后的输出目录 filename: "[name]-[hash].bundle.js" &#125;, module: &#123; rules: [ &#123; test: /\.css$/, // css处理为style标签 use: [ "style-loader", 'css-loader' ] &#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: '设置html的title',// 当设置了template选项后，title选项将失效 filename: "index.html", template: "./index.html", minify: &#123; // 压缩选项 collapseWhitespace: true &#125; &#125;), new CleanWebpackPlugin(["dist"]) ]&#125;; 6.执行打包命令 (默认你已经安装了全局 webpack 以及 webpack-cli ) 1webpack 7.验证打包结果每次进行 webpack 打包都会先清除 dist 目录 8.源码地址demo 代码地址: https://github.com/SimpleCodeCX/simple-webpack-demos/tree/master/demo17-clean仓库代码地址(及目录): https://github.com/SimpleCodeCX/simple-webpack-demos]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4实践笔记16 webpack 处理字体]]></title>
    <url>%2Fblog%2F20190311%2F7be060d8.html</url>
    <content type="text"><![CDATA[通过 url-loader 和 file-loader 配合可以实现：当字体大小 &lt; 某个限定值（limit）时，转换为 base64 字符传，并打包进 bundle 中。当字体大小 &gt; 某个限定值时，将图片放到指定目录下，并通过 url 引用。 本系列代码放在 github 上: webpack4系列实践代码如果本系列实践教程对你有帮助,欢迎给个 github star 哦! 1.关于字体 字体的格式有很多种，各个浏览器对各个字体格式的支持程度也不同，字体格式有以下几种： TureTpe(.ttf) 格式 支持 IE9+,Firefox3.5+,Chrome4+,Safari3+,Opera10+,iOS Mobile Safari4.2+ OpenType(.otf) 格式 支持 Firefox3.5+,Chrome4.0+,Safari3.1+,Opera10.0+,iOS Mobile Safari4.2+ Embedded Open Type(.eot) 格式： 支持 IE4+ Web Open Font Format(.woff) 格式： 支持 IE9+,Firefox3.5+,Chrome6+,Safari3.6+,Opera11.1+ SVG(.svg) 格式： 支持 IE9+,Chrome4+,Safari3.1+,Opera10.0+,iOS Mobile Safari3.2+ 定义@font-face 12345678910@font-face &#123; font-family: "icomoon"; src: url("./icomoon.eot?nn7hff"); src: url("./icomoon.eot?nn7hff#iefix") format("embedded-opentype"), url("./icomoon.ttf?nn7hff") format("truetype"), url("./icomoon.woff?nn7hff") format("woff"), url("./icomoon.svg?nn7hff#icomoon") format("svg"); font-weight: normal; font-style: normal;&#125; 使用字体123.div1 &#123; font-family: "icomoon" !important;&#125; 2.制作自定义字体通过 IcoMoon 平台，我们可以挑选和定制项目所用到的字体 icon ，最后导出字体的 eot , svg , woff , ttf 格式，并包含一个定义了 @font-face 的 css 文件，也就是说我们不需要自己去定义 @font-face ，只要引用这份 css 文件，即可使用到字体图标。 IconMon 平台导出的文件包大概如下：12345icomoon.eoticomoon.svgicomoon.ttficomoon.woffstyle.css // 定义了 @font-face，以及使用字体的相关样式 3.通过 url-loader 和 file-loader 处理字体通过 url-loader 和 file-loader 配合可以实现： 当字体大小 &lt; 某个限定值（limit）时，转换为 base64 字符传，并打包进 bundle 中。 当字体大小 &gt; 某个限定值时，将图片放到指定目录下，并通过 url 引用。 当字体大小比较小时，可以把字体转化为 base64 字符串，从而减少一次浏览器发起 http 请求。 当字体比较大时，就没必要了，因为 base64 转换后，总体积会变大，此时比不上多一次 http 请求的性能。 4.安装相关依赖1234npm install -D css-loader style-loadernpm install -D file-loader url-loadernpm install -D html-webpack-plugin mini-css-extract-pluginnpm install -D webpack // html-webpack-plugin、mini-css-extract-plugin 依赖于 webpack 5.目录结构123456789101112131415// `--` 代表目录， `-` 代表文件 --demo14 font --src --assets --fonts -icomoon.css -icomoon.eot //3KB -icomoon.svg //5KB -icomoon.ttf //3KB -icomoon.woff //3KB --styles -app.css -app.js -index.html -webpack.config.js src/assets/fonts/icomoon.css12345678910111213141516171819202122232425262728293031323334353637@font-face &#123; font-family: "icomoon"; src: url("./icomoon.eot?nn7hff"); src: url("./icomoon.eot?nn7hff#iefix") format("embedded-opentype"), url("./icomoon.ttf?nn7hff") format("truetype"), url("./icomoon.woff?nn7hff") format("woff"), url("./icomoon.svg?nn7hff#icomoon") format("svg"); font-weight: normal; font-style: normal;&#125;[class^="icon-"],[class*=" icon-"] &#123; /* use !important to prevent issues with browser extensions that change fonts */ font-family: "icomoon" !important; speak: none; font-style: normal; font-weight: normal; font-variant: normal; text-transform: none; line-height: 1; /* Better Font Rendering =========== */ -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125;.icon-wechat:before &#123; content: "\e900"; color: #7bb32e;&#125;.icon-github:before &#123; content: "\e902";&#125;.icon-envelop:before &#123; content: "\e945";&#125; src/assets/styles/app.css1234567891011.icons-box &#123; width: 500px; height: 100px; margin: auto; margin-top: 180px;&#125;.icons-box i &#123; font-size: 100px; margin-left: 20px;&#125; src/app.js 12import "./assets/fonts/icomoon.css";import "./assets/styles/app.css"; 6.编写 webpack 配置文件webpack.config.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const path = require("path");const MiniCssExtractPlugin = require("mini-css-extract-plugin");const HtmlWebpackPlugin = require("html-webpack-plugin");module.exports = &#123; entry: &#123; app: "./src/app.js" &#125;, output: &#123; publicPath: __dirname + "/dist/", // 打包后资源文件的引用会基于此路径 path: path.resolve(__dirname, "dist"), // 打包后的输出目录 filename: "[name].bundle.js", chunkFilename: "[name].chunk.js" &#125;, module: &#123; rules: [ &#123; test: /\.css$/, use: [ MiniCssExtractPlugin.loader, "css-loader" ] &#125;, &#123; test: /\.(eot|woff2?|ttf|svg)$/, use: [ &#123; loader: "url-loader", options: &#123; name: "[name]-[hash:5].min.[ext]", limit: 3000, // size &lt;= 3000B, 改成5000B试试? publicPath: "fonts/", outputPath: "fonts/" &#125; &#125; ] &#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; // 自动生成html,并且自动导入所有依赖同步包 filename: "index.html", template: "./index.html", minify: &#123; // collapseWhitespace: true // 压缩 &#125; &#125;), new MiniCssExtractPlugin(&#123; filename: "[id].[name].[chunkhash:8].css", chunkFilename: "[id].[name].[chunkhash:8].css" &#125;) ]&#125;; 7.执行打包命令 (默认你已经安装了全局 webpack 以及 webpack-cli ) 1webpack 8.验证打包结果输出结果: 123456--dist --fonts -icomoon-69ba6.min.svg //5KB -0.app.a3d3cc59.css -app.bundle.js -index.html &lt;= 3KB 的字体文件被转换成 base64 字符串并打包进 app.bundle.js 中。 icomoon.svg(18.6KB) =&gt; icomoon-69ba6.min.svg 把 limit 改成 5000 试试? 9.源码地址demo 代码地址: https://github.com/SimpleCodeCX/simple-webpack-demos/tree/master/demo16-font仓库代码地址(及目录): https://github.com/SimpleCodeCX/simple-webpack-demos]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4实践笔记15 webpack 处理图片]]></title>
    <url>%2Fblog%2F20190311%2F1275f9d9.html</url>
    <content type="text"><![CDATA[通过 url-loader 和 file-loader 配合可以实现：当图片大小 &lt; 某个限定值（limit）时，转换为 base64 字符传，并打包进 bundle 中。当图片大小 &gt; 某个限定值时，将图片放到指定目录下，并通过 url 引用。 本系列代码放在 github 上: webpack4系列实践代码如果本系列实践教程对你有帮助,欢迎给个 github star 哦! demo15 webpack 处理图片1.通过 url-loader 和 file-loader 处理图片通过 url-loader 和 file-loader 配合可以实现： 当图片大小 &lt; 某个限定值（limit）时，转换为 base64 字符传，并打包进 bundle 中。 当图片大小 &gt; 某个限定值时，将图片放到指定目录下，并通过 url 引用。 2.关于 url-loaderurl-loader: 可以将 css 文件中的字体和图片 url 转化为 base64 字符串，从而减少对资源的发起 http 请求次数。 url-loader 的配置参数如下： limit {Number} : 设置一个限定值（单位字节） 当图片或字体的大小 &lt; limit 时，会被转成 base64，并打包进 bundle 中 当图片或字体的大小 &gt; limit 时，默认会调用 file-loader 来处理图片 在没有配置 limit (单位字节) 值的情况下，所有大小的图片都会被转成base64 mimetype {String} : 设置 base64 格式的编码格式，没有设置此属性时，默认根据图片扩展名来判断 例如 mimetype: &#39;image/png&#39; fallback {String} : 当图片或字体的大小 &gt; limit 时，默认会使用 url-loader 来处理，也可以通过此属性设置其他的 loader 来处理 ( 注意: file-loader 和 url-loader 共享同一个 options , file-loader 和 url-loader 的 option 是不冲突的 ) 配置示例: (处理图片)1234567891011121314&#123; test: /\.(png|jpg|jpeg|gif)$/, // 处理图片 use: [ &#123; loader: 'url-loader', options: &#123; limit: 8192, // size &lt;= 8KB name: 'img/[hash].[ext]', // 属于file-loader的属性 publicPath: "fonts/", // 属于file-loader的属性 outputPath: "fonts/" // 属于file-loader的属性 &#125; &#125; ]&#125; (处理字体)1234567891011121314&#123; test: /\.(eot|woff2?|ttf|svg)$/, // 处理字体 use: [ &#123; loader: "url-loader", options: &#123; limit: 5000, // size &lt;= 5KB name: "[name]-[hash:5].min.[ext]", // 属于file-loader的属性 publicPath: "fonts/", // 属于file-loader的属性 outputPath: "fonts/" // 属于file-loader的属性 &#125; &#125; ]&#125; 3.关于 file-loader实现对文件进行处理，比如修改文件名，并且输出到指定的路径，file-loader 可以单独使用，也可以与 url-loader 一起使用。 url-loader 在处理图片或字体时，当文件的大小大于 limit 时，默认使用 file-loader 来处理。 file-loader 的配置参数如下： name [name] 原文件名字，不包含扩展名 [hash:8] hash 值，默认是 32 位 [ext] 原文件扩展名 [path] 实际上是相对于 context 的路径，context 默认是 webpack.config.js 的路径 context 影响[path],默认为 webpack.config.js context publicPath 打包后资源文件的引用会基于此路径，也可以设置为 cdn：https://www.xxx.com/img。（默认使用 output 的 publicPath 属性） outputPath publicPath/outputPath/[name].[ext] 4.目录结构这里准备了三张图片，大小分别是：18.6k、12.1k、14.9k。并设置 limit:15360 (15k)， 12345678910111213// `--` 代表目录， `-` 代表文件 --demo15 --src --assets --imgs -1.png //18.6KB -2.png //12.1KB -3.png //14.9KB --styles -app.css -app.js -index.html -webpack.config.js src/assets/styles/app.css 12345678910111213141516171819202122*,body &#123; margin: 0; padding: 0;&#125;.container div&#123; width:200px; height: 200px; float: left;&#125;.div1&#123; background: url("../imgs/1.png") no-repeat;&#125;.div2&#123; background: url("../imgs/2.png") no-repeat;&#125;.div3&#123; background: url("../imgs/3.png") no-repeat;&#125; src/app.js1234567// 同步加载import "./assets/styles/app.css";// window.addEventListener("click", function () &#123;// // 试试异步加载? 查看浏览器控制台试试// import("./assets/styles/app.css");// &#125;); 5.安装相关依赖123npm install -D css-loader style-loadernpm install -D file-loader url-loadernpm install -D html-webpack-plugin webpack 6.编写 webpack 配置文件webpack.config.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const path = require("path");const HtmlWebpackPlugin = require("html-webpack-plugin");module.exports = &#123; entry: &#123; app: "./src/app.js" &#125;, output: &#123; publicPath: __dirname + "/dist/", // 打包后资源文件的引用会基于此路径 path: path.resolve(__dirname, "dist"), // 打包后的输出目录 filename: "[name].bundle.js" &#125;, module: &#123; rules: [ &#123; test: /\.css$/, // 以&lt;style&gt;标签形式引用css use: [ "style-loader", "css-loader" ] &#125;, &#123; test: /\.(png|jpg|jpeg|gif)$/, use: [ &#123; loader: "url-loader", options: &#123; limit: 15360, // size &lt;= 15KB, 改成15257(&lt;14.9KB)试试? name: "[name]-[hash:5].min.[ext]", // 设置文件名(&gt;limit的情况) publicPath: "static/", // 设置资源文件的引用根路径 outputPath: "static/" // publicPath/outputPath/[name].[ext] &#125; &#125; ] &#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; // 自动生成html,并且自动导入所有依赖同步包 filename: "index.html", template: "./index.html", minify: &#123; // collapseWhitespace: true // 压缩 &#125; &#125;), ]&#125;; 7.执行打包命令 (默认你已经安装了全局 webpack 以及 webpack-cli ) 1webpack 8.验证打包结果输出结果: 12345--dist --static -1-bd4ee.min.png //18.6KB -app.bundle.js -index.html 2.png (12.1KB) 和 3.png (14.9KB) 被转换成 base64 字符串并打包进 app.bundle.js 中。 1.png(18.6KB) =&gt; 1-bd4ee.min.png 把 limit 改成 15257 (&lt;14.9KB) 试试? 9.源码地址demo 代码地址: https://github.com/SimpleCodeCX/simple-webpack-demos/tree/master/demo15-img仓库代码地址(及目录): https://github.com/SimpleCodeCX/simple-webpack-demos]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4实践笔记14 mini-css-extract-plugin + SplitChunksPlugin 处理 css 和 scss]]></title>
    <url>%2Fblog%2F20190311%2Fb166f567.html</url>
    <content type="text"><![CDATA[虽然webpack4不支持 ExtractTextWebpackPlugin 插件，但是我们可以使用 mini-css-extract-plugin 来实现把 css 提取为单独的文件。 本系列代码放在 github 上: webpack4系列实践代码如果本系列实践教程对你有帮助,欢迎给个 github star 哦! 1.关于 mini-css-extract-plugin虽然webpack4不支持 ExtractTextWebpackPlugin 插件，但是我们可以使用 mini-css-extract-plugin 来实现把 css 提取为单独的文件。 相比 ExtractTextWebpackPlugin，mini-css-extract-plugin 有如下优点： 异步加载 不重复编译，性能更好 更容易使用 只针对CSS 但目前 mini-css-extract-plugin 不支持HMR。 详情见 mini-css-extract-plugin 官方文档：https://github.com/webpack-contrib/mini-css-extract-plugin mini-css-extract-plugin 的作用在于能够将所有的入口 chunk (entry chunks) 中引用的 *.css，移动到独立分离的 CSS 文件中。 因此，你的样式将不再内嵌到 JS bundle 中，而是会放到一个单独的 CSS 文件（比如 styles.css）当中。 如果你的样式文件大小较大，这会做更快提前加载，因为 CSS bundle 会跟 JS bundle 并行加载。 使用 mini-css-extract-plugin 优点： CSS 请求并行 CSS 单独缓存 缺点在于： 需要额外的 HTTP 请求 虽然 file-loader 也可以把 css 单独提取到 css 文件，但是无法合并多个css文件 2.关于打包方案（与 SplitChunksPlugin 结合） 为 Vendor 单独打包（Vendor 指第三方的库或者公共的基础组件，因为 Vendor 的变化比较少，单独打包利于缓存） 为 Manifest （Webpack 的 Runtime 代码）单独打包 为不同入口的公共业务代码打包（同理，也是为了缓存和加载速度） 为异步加载的代码打一个公共的包 https://juejin.im/post/5b304f1f51882574c72f19b0 3.异步 css 和异步 js注意css的同步加载还是异步加载的引用方式： 同步加载：import ‘./style2.css’; 异步加载：import(‘./style2.css’); 两种的打包结果是不一样的 4.自动生成 html HtmlWebpackPluginHtmlWebpackPlugin 简化了 HTML 文件的创建，以便为你的 webpack 包提供服务。这对于在文件名中包含每次会随着编译而发生变化哈希的 webpack bundle 尤其有用。 你可以让插件为你生成一个HTML文件，使用 lodash 模板提供你自己的模板，或使用你自己的 loader。 https://segmentfault.com/a/1190000007294861#articleHeader8 5.安装相关依赖(注意：mini-css-extract-plugin 依赖于 webpack，因此需要在项目下安装 webpack)1234npm install -D webpacknpm install -D css-loadernpm install -D mini-css-extract-pluginnpm install -D html-webpack-plugin 6.目录结构123456789101112131415161718// `--` 代表目录， `-` 代表文件 --demo14 --src --module1(同步模块) -module1.css -module1.js --module2(异步模块) -module2.css -module2.js --styles -async-style.css -common.css -app.js --vendor(第三方包) -vendor.css -vendor.js -index.html s-webpack.config.js src/module1/module1.css 123body &#123; color: black;&#125; src/module1/module1.js 12import './module1.css';console.log('这里是同步module1'); src/module2/module2.css 123body &#123; font-size: 100px;&#125; src/module2/module2.js 12import './module2.css';console.log('这里是异步module2'); src/styles/async-style.css 123body &#123; background-color: red;&#125; src/styles/common.css 123body &#123; font-family: monospace, "Microsoft Yahei", "微软雅黑", STXihei, "华文细黑";&#125; vendor/vendor.css 1234/* 第三方包css */body &#123; border: 1px solid black;&#125; vendor/vendor.js 123// 这里假设vendor为第三方包import './vendor.css';console.log('这里是第三方依赖包'); src/app.js 1234567891011121314151617181920// 同步加载common.cssimport './styles/common.css';// 同步加载module1.jsimport * as module1 from './module1/module1';// 同步加载第三方包vendor.jsimport * as vendor from '../vendor/vendor';window.addEventListener('click', function () &#123; // 异步加载module2.js import(/* webpackChunkName: 'module2'*/ './module2/module2').then(_ =&gt; &#123; console.log('加载异步module2成功'); &#125;); // async-style.css import(/* webpackChunkName: 'async-style'*/'./styles/async-style.css').then(_ =&gt; &#123; console.log('加载异步async-style.css成功'); &#125;);&#125;); 7.编写 webpack 配置文件webpack.config.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162const path = require("path");const MiniCssExtractPlugin = require("mini-css-extract-plugin");const HtmlWebpackPlugin = require("html-webpack-plugin");module.exports = &#123; mode: 'production' || 'development' || 'production', entry: &#123; app: "./src/app.js" &#125;, output: &#123; publicPath: __dirname + "/dist/", // 打包后资源文件的引用会基于此路径 path: path.resolve(__dirname, "dist"), // 打包后的输出目录 filename: "[id].[name].[chunkhash:8].bundle.js", // 在development模式下,id为name chunkFilename: "[id].[name].[chunkhash:8].chunk.js" &#125;, module: &#123; rules: [ &#123; test: /\.css$/, use: [ MiniCssExtractPlugin.loader, 'css-loader', ] &#125; ] &#125;, optimization: &#123; runtimeChunk: "single", // webpack运行时代码单独提取为一个包 splitChunks: &#123; cacheGroups: &#123; async: &#123; // 为异步代码打成一个公共包(在app.js修改一下代码,重新打包,不影响此包hash) name: 'async', chunks: 'async', // 为异步代码打包 minChunks: 1, minSize: 0 &#125;, vendors: &#123; // 由于第三方代码变动比较小，所以把所有第三方单独打包，利于缓存(在app.js修改一下代码,重新打包,不影响此包hash) test: /[\\/]vendor[\\/]/, name: 'vendor', chunks: 'all', // 设置为all minChunks: 1, minSize: 0// 这里为了演示，设置为0以满足打包条件 &#125; &#125; &#125; &#125;, plugins: [ new HtmlWebpackPlugin(&#123; // 自动生成html,并且自动导入所有依赖同步包 filename: "index.html", template: "./index.html", minify: &#123; // collapseWhitespace: true // 压缩 &#125; &#125;), new MiniCssExtractPlugin(&#123; filename: "[id].[name].[chunkhash:8].css", chunkFilename: "[id].[name].[chunkhash:8].css" &#125;) ]&#125; 8.执行打包命令 (默认你已经安装了全局 webpack 以及 webpack-cli ) 1webpack 9.验证打包结果输出结果：123456780.async.512ec03b.chunk.js0.async.512ec03b.css1.app.4cfbacec.chunk.js1.app.4cfbacec.css2.runtime.0d1b9de2.bundle.js3.vendor.c1185876.chunk.js3.vendor.c1185876.cssindex.html 在浏览器运行 dist/index.html 查看效果。 10.源码地址demo 代码地址: https://github.com/SimpleCodeCX/simple-webpack-demos/tree/master/demo14-mini仓库代码地址(及目录): https://github.com/SimpleCodeCX/simple-webpack-demos]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4实践笔记13 webpack通过postcss-loader加工css和scss]]></title>
    <url>%2Fblog%2F20190311%2F41443a76.html</url>
    <content type="text"><![CDATA[postcss: postcss 有一个插件体系，postcss 可以通过选择相应的插件对 css 进行转换和处理。比如可以通过 Autoprefixer 插件来处理 css 的前缀，以实现浏览器的兼容性。postcss-loader: webpack 通过 postcss-loader 来调用 postcss。 本系列代码放在 github 上: webpack4系列实践代码如果本系列实践教程对你有帮助,欢迎给个 github star 哦! 1.关于 postcss-loader 和 postcss postcss: postcss 有一个插件体系，postcss 可以通过选择相应的插件对 css 进行转换和处理。比如可以通过 Autoprefixer 插件来处理 css 的前缀，以实现浏览器的兼容性。 postcss-loader: webpack 通过 postcss-loader 来调用 postcss。 关于 PostCss 的文档： 英文文档: https://github.com/postcss/postcss 中文文档: https://github.com/postcss/postcss/blob/master/README-cn.md 2.webpack 如何配置 postcss 在 postcss-loader 的 options 中配置 postcss123456789&#123; loader: 'postcss-loader', options: &#123; ident: "postcss", plugins: [ require("autoprefixer") /* postcss 调用 autoprefixer 插件*/ ] &#125;&#125; 通过配置文件 postcss.config.js123456module.exports = &#123; parser: 'postcss', plugins: &#123; 'autoprefixer': &#123;&#125; &#125;&#125; 3.安装相关依赖12npm install -D css-loader style-loadernpm install -D postcss-loader postcss autoprefixer 4.目录结构// -- 代表目录， - 代表文件12345678--demo13 --src -app.js -style1.css -style2.css -index.html -postcss.config.js -webpack.config.js 5.编写 postcss.config.js 配置文件webpack.config.js 123456module.exports = &#123; parser: 'postcss', plugins: &#123; 'autoprefixer': &#123;&#125; &#125;&#125; 6.编写 webpack 配置文件webpack.config.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667const path = require("path");module.exports = &#123; mode: 'development', entry: &#123; app: "./src/app.js" &#125;, output: &#123; publicPath: __dirname + "/dist/", // 打包后资源文件的引用会基于此路径 path: path.resolve(__dirname, "dist"), // 打包后的输出目录 filename: "[name].bundle.js" &#125;, module: &#123; rules: [ &#123; test: /\.css$/, // 以&lt;style&gt;标签形式引用css use: [ &#123; loader: "style-loader", options: &#123; singleton: true // 处理为单个style标签,注释掉试试看? &#125; &#125;, 'css-loader', &#123; loader: 'postcss-loader', // 配置在postcss.config.js // options: &#123; // ident: "postcss", // plugins: [ // require("autoprefixer") /*postcss调用autoprefixer插件*/ // ] // &#125; &#125; ] &#125; ], // rules: [ // &#123; // test: /\.css$/, // // 以&lt;link&gt;标签形式引用css // use: [ // "style-loader/url", // &#123; // loader: "file-loader", // options: &#123; // name: '[name].[hash].css' // &#125; // &#125;, // &#123; // loader: 'postcss-loader', // // 配置在postcss.config.js // // options: &#123; // // plugins: [ // // require("autoprefixer") /*postcss调用autoprefixer插件*/ // // ] // // &#125; // &#125; // ] // &#125; // ] &#125;&#125;; 7.执行打包命令 (默认你已经安装了全局 webpack 以及 webpack-cli ) 1webpack 8.验证打包结果transform 样式被添加了相应的前缀。 1234transform: all 1s;--------》-webkit-transform: all 1s; transform: all 1s; 9.源码地址demo 代码地址: https://github.com/SimpleCodeCX/simple-webpack-demos/tree/master/demo13-postcss仓库代码地址(及目录): https://github.com/SimpleCodeCX/simple-webpack-demos]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4实践笔记12 webpack 处理 scss]]></title>
    <url>%2Fblog%2F20190311%2F5bb783a3.html</url>
    <content type="text"><![CDATA[webpack 处理 scss 本系列代码放在 github 上: webpack4系列实践代码如果本系列实践教程对你有帮助,欢迎给个 github star 哦! 1.如何处理 scsssass-loader &gt; css-loader &gt; style-loader (以 &lt;style&gt; 标签形式添加到 html 中) 或 sass-loader &gt; file-loader &gt; style-loader/url (以 &lt;link&gt; 标签形式添加到 html 中) sass-loader: 处理 sass/scss 文件，并且把它们编译成 css css-loader: 处理 css，并把 css 代码转化为一个 js module style-loader: 实现把加载的 css 代码以 style 标签的形式插入到 html 中 file-loader: 在这里实现把 css 提取为文件 2.安装相关依赖 注意：sass-loader 依赖于 node-sass 12npm install -D sass-loader node-sassnpm install -D css-loader style-loader file-loader 3.目录结构12345678// `--` 代表目录， `-` 代表文件 --demo12 --src -app.js -style1.scss -style2.scss -index.html -webpack.config.js src/app.js12345678910// 同步加载// import &quot;./style1.scss&quot;;// import &quot;./style2.scss&quot;;window.addEventListener(&quot;click&quot;, function () &#123; // 试试异步加载? 查看控制台试试 const style1 = import(&quot;./style1.scss&quot;); const style2 = import(&quot;./style2.scss&quot;);&#125;); src/style1.scss1234$bgColor: red;body &#123; background-color: $bgColor;&#125; src/style2.scss1234$color: black;body &#123; color: $color;&#125; 4.编写 webpack 配置文件webpack.config.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const path = require(&quot;path&quot;);module.exports = &#123; entry: &#123; app: &quot;./src/app.js&quot; &#125;, output: &#123; publicPath: __dirname + &quot;/dist/&quot;, // 打包后资源文件的引用会基于此路径 path: path.resolve(__dirname, &quot;dist&quot;), // 打包后的输出目录 filename: &quot;[name].bundle.js&quot; &#125;, module: &#123; rules: [ &#123; test: /\.scss$/, // 以&lt;style&gt;标签形式引用css use: [ &#123; loader: &quot;style-loader&quot;, // 将 JS 字符串生成为 style 节点 options: &#123; singleton: true // 处理为单个style标签,注释掉试试看? &#125; &#125;, &quot;css-loader&quot;, // 将 CSS 转化成 CommonJS 模块 &quot;sass-loader&quot; // 将 Sass/Scss 编译成 CSS ] &#125; ], // rules: [ // &#123; // test: /\.scss$/, // // 以&lt;link&gt;标签形式引用css // use: [ // &quot;style-loader/url&quot;, // &#123; // loader: &quot;file-loader&quot;, // options: &#123; // name: &apos;[name].[hash].css&apos; // &#125; // &#125;, // &quot;sass-loader&quot; // ] // &#125; // ] &#125;&#125;; 5.执行打包命令 (默认你已经安装了全局 webpack 以及 webpack-cli ) 1webpack 打包成功后，结果输出在 dist 目录中 6.查看打包结果创建 index.html 文件,引用打包生成的主文件 (这里是 app.bundle.js),1&lt;script src="./dist/app.bundle.js"&gt;&lt;/script&gt; 在浏览器打开， 在 模式下，会发现 scss 被转化为css后以 &lt;style&gt; 的方式添加在 &lt;head&gt; 中，并且在设置 singleton 为 true 时，webpack 会把多个 css 文件合并在同一个 &lt;style&gt; 中。 在 模式下，会发现 scss 文件被转化 css 文件，并以 &lt;link&gt; 的方式引用在 &lt;head&gt; 中。 7.源码地址demo 代码地址: https://github.com/SimpleCodeCX/simple-webpack-demos/tree/master/demo12-scss仓库代码地址(及目录): https://github.com/SimpleCodeCX/simple-webpack-demos]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4实践笔记11 webpack处理css]]></title>
    <url>%2Fblog%2F20190311%2F28ba9e99.html</url>
    <content type="text"><![CDATA[在 webpack 中，所有类型的文件都是模块，比如 js、css、图片、字体、json（可以说是万物皆模块）。但是，在普通的 js 代码中，我们直接 import (或require) 一张图片或css是会报错的。但在 webpack 构建的项目中，归功于 loader（加载器），webpack 能够把 js 的模块化推广至其他类型文件，比如：import(&#39;xxx.css&#39;); 本系列代码放在 github 上: webpack4系列实践代码如果本系列实践教程对你有帮助,欢迎给个 github star 哦! 1.关于模块在 webpack 中，所有类型的文件都是模块，比如 js、css、图片、字体、json（可以说是万物皆模块）。 但是，在普通的 js 代码中，我们直接 import (或require) 一张图片或css是会报错的。 但在 webpack 构建的项目中，归功于 loader（加载器），webpack 能够把 js 的模块化推广至其他类型文件，比如：1import('xxx.css'); // 通过css-loader处理 2.处理 css 为什么要通过 webpack传统引用 css 代码的方式是在 html 通过 &lt;style&gt; 或 &lt;link&gt; 标签来引入样式。 但是这样不是很方便，借助 webpack 的 style-loader 和 css-loader 等 loader (或plugin)，我们可以实现在 .js 或者 .ts 中引用 css 文件，并让样式以 &lt;style&gt; 或者 &lt;link&gt; 的方式自动添加到 html 文件中。 3.相关 loader 或 plugincss-loader: 实现在 js 代码中加载 css 文件,并把 css 代码转化为 js 的一个 module ,比如 import(&#39;./xxx.css&#39;) style-loader: 实现把加载的 css 代码作为 style 标签内容插入到 html 中 style-loader/url: 实现把加载的 css 代码以 link 内容插入到 html 中 file-loader: 实现对文件进行处理，比如修改文件名，并且输出到指定的路径，file-loader 可以单独使用，也可以和 url-loader 一起使用 4.分别实现以 &lt;style&gt; 和 &lt;link&gt; 的方式引用 css 4.1 以 &lt;style&gt; 方式引用 css 需要的 loader 为: css-loader + style-loader webpack.config.js 关键配置如下：12345678910111213141516rules: [ &#123; test: /\.css$/, // 以&lt;style&gt;标签形式引用css use: [ &#123; loader: "style-loader", options: &#123; singleton: true // 处理为单个style标签,注释掉试试看? &#125; &#125;, "css-loader" ] &#125; ], 4.2 以 &lt;link&gt; 方式引用 css 需要的 loader 为: file-loader + style-loader/url (与 style-loader 是同一个包) webpack.config.js 关键配置如下：1234567891011rules: [ &#123; test: /\.css$/, // 以&lt;link&gt;标签形式引用css use: [ "style-loader/url", "file-loader" ] &#125;] 5.安装相关依赖123npm install -D css-loadernpm install -D style-loadernpm install -D file-loader 6.目录结构12345678// `--` 代表目录， `-` 代表文件 --demo11 --src -app.js -style1.css -style2.css -index.html -webpack.config.js src/app.js12345678910// 同步加载const style1 = import("./style1.css");const style2 = import("./style2.css");// window.addEventListener("click", function () &#123;// // 试试异步加载? 查看控制台试试// const style1 = import("./style1.css");// const style2 = import("./style2.css");// &#125;); src/style1.css1234body &#123; background-color: red;&#125;/* console.log('11111'); */ src/style2.css123body &#123; color: black;&#125; 7.编写 webpack 配置文件webpack.config.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const path = require("path");module.exports = &#123; entry: &#123; app: "./src/app.js" &#125;, output: &#123; publicPath: __dirname + "/dist/", // 打包后资源文件的引用会基于此路径 path: path.resolve(__dirname, "dist"), // 打包后的输出目录 filename: "[name].bundle.js" &#125;, module: &#123; rules: [ &#123; test: /\.css$/, // 以&lt;style&gt;标签形式引用css use: [ &#123; loader: "style-loader", options: &#123; singleton: true // 处理为单个style标签,注释掉试试看? &#125; &#125;, "css-loader" ] &#125; ], // rules: [ // &#123; // test: /\.css$/, // // 以&lt;link&gt;标签形式引用css // use: [ // "style-loader/url", // &#123; // loader: "file-loader", // options: &#123; // name: '[name].[hash].css' // &#125; // &#125; // ] // &#125; // ] &#125;&#125;; 8.执行打包命令 (默认你已经安装了全局 webpack 以及 webpack-cli ) 1webpack 9.查看打包结果创建 index.html 文件,引用打包生成的主文件 (这里是 app.bundle.js),1&lt;script src="./dist/app.bundle.js"&gt;&lt;/script&gt; 在浏览器打开， 在 模式下，会发现 css 以 &lt;style&gt; 的方式添加在 &lt;head&gt; 中，并且在设置 singleton 为 true 时，webpack 会把多个 css 文件合并在同一个 &lt;style&gt; 中。 在 模式下，会发现 css 以 &lt;link&gt; 的方式引用在 &lt;head&gt; 中。 10.源码地址demo 代码地址: https://github.com/SimpleCodeCX/simple-webpack-demos/tree/master/demo11-css仓库代码地址(及目录): https://github.com/SimpleCodeCX/simple-webpack-demos]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4实践笔记10 关于JS Tree Shaking]]></title>
    <url>%2Fblog%2F20190311%2F87d97ce2.html</url>
    <content type="text"><![CDATA[借助于 es6 (es2015) 模块系统 (import 和 export) 的静态解析，webpack 能够利用 Tree Shaking 进行按需加载，移除掉没有被引用的模块，从而减少包的大小，缩小应用的加载时间，从而提高性能体验。 本系列代码放在 github 上: webpack4系列实践代码如果本系列实践教程对你有帮助,欢迎给个 github star 哦! 1.什么是 tree shaking借助于 es6 (es2015) 模块系统 (import 和 export) 的静态解析，webpack 能够利用 Tree Shaking 进行按需加载，移除掉没有被引用的模块，从而减少包的大小，缩小应用的加载时间，从而提高性能体验。 2.需配合 UglifyJSPlugin 来实现 tree shakingUglifyJSPlugin 的作用在于删除未被引用代码以及压缩代码。 从 webpack 4 开始，只需将 &quot;mode&quot; 设置为 &quot;production&quot; 模式，即可开启 UglifyJSPlugin 的功能。 详情可参考官方 Tree Shaking 文档：https://www.webpackjs.com/guides/tree-shaking/ 3.目录结构123456// `--` 代表目录， `-` 代表文件 --demo10 --src -app.js -module.js -webpack.config.js module.js1234567891011export const sayHello1 = () =&gt; &#123; console.log('hello1');&#125;export const sayHello2 = () =&gt; &#123; console.log('hello2');&#125;export const sayHello3 = () =&gt; &#123; console.log('hello3');&#125; app.js1234// 只导入了 sayHello1 ,观察打包后的 bundle 代码，移除了 sayHello2 和 sayHello3 的代码import &#123; sayHello1 &#125; from './module';sayHello1(); 4.编写webpack配置文件webpack.config.js 12345678910111213const path = require("path");module.exports = &#123; mode: "production" || "development", // tree shaking 需要使用 "production" 模式 entry: &#123; app: "./src/app.js" &#125;, output: &#123; publicPath: __dirname + "/dist/", // 打包后资源文件的引用会基于此路径 path: path.resolve(__dirname, "dist"), // 打包后的输出目录 filename: "[name].bundle.js" &#125;&#125;; 5.执行打包命令 (默认你已经安装了全局 webpack 以及 webpack-cli ) 1webpack 打包成功后，会在 demo08 目录下生成 dist/app.bundle.js 6.验证 tree shaking 是否生效打开 app.bundle.js 文件， 发现查找不到 Hi I want to say hello2 和 Hi I want to say hello3 , 说明 Tree Shaking 生效了。 7.源码地址demo 代码地址: https://github.com/SimpleCodeCX/simple-webpack-demos/tree/master/demo10-tree-shaking仓库代码地址(及目录): https://github.com/SimpleCodeCX/simple-webpack-demos 参考文档：tree shaking]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4实践笔记9 使用 SplitChunksPlugin 分离第三方依赖包以及异步包]]></title>
    <url>%2Fblog%2F20190311%2Fecf0b61.html</url>
    <content type="text"><![CDATA[在单页面或多页面应用中，通过代码分离的方式，能够优化性能。比如把异步加载的代码分离成一个单独的chunk，等到需要调用的时候再按需加载（比如click时），这样可以减少首屏的代码体积，从而提高首屏的加载速度。 本系列代码放在 github 上: webpack4系列实践代码如果本系列实践教程对你有帮助,欢迎给个 github star 哦! 1.为什么要代码分离在单页面或多页面应用中，通过代码分离的方式，能够优化性能。 比如把异步加载的代码分离成一个单独的chunk，等到需要调用的时候再按需加载（比如click时），这样可以减少首屏的代码体积，从而提高首屏的加载速度。 另外，在我们的项目中，可能会用到很多的第三方库（比如 lodash 、rxjs 等），而往往这些第三方依赖库的代码一般很少变化，因此，很适合把第三方依赖库单独分离成一个包，并且包名包含 hash（ webpack 可以轻松做到），这样的好处在于，可以配合浏览器http的缓存机制。（比如 max-age ），实现对相关资源包的长缓存，从而优化性能。 一般需要代码分割的场景有： 分离业务代码和第三方依赖 分离首次加载和异步加载的代码 分离业务代码和业务的公用代码 2.安装相关依赖 通过 html-webpack-plugin 自动生成 index.html 123npm install -D html-webpack-pluginnpm install -D webpack // html-webpack-plugin 依赖于 webpacknpm install --save axios lodash 3.目录结构123456789// `--` 代表目录， `-` 代表文件 --demo09 --src -app.js -async-module1.js -async-module2.js -module.js -index.html -webpack.config.js src/async-module1.js1export const data = 'this is async module1'; src/async-module2.js1export const data = 'this is async module2'; src/module.js1234567891011export const sayHello1 = () =&gt; &#123; console.log('Hi I want to say hello1');&#125;export const sayHello2 = () =&gt; &#123; console.log('Hi I want to say hello2');&#125;export const sayHello3 = () =&gt; &#123; console.log('Hi I want to say hello3');&#125; src/app.js12345678910111213141516171819202122232425262728293031323334353637383940import &#123; sayHello1, sayHello2, sayHello3 &#125; from './module';sayHello1();sayHello2();sayHello3();// 异步加载 async-module1setTimeout(() =&gt; &#123; require.ensure( [], function () &#123; const asyncModule = require("./async-module1"); console.log(asyncModule.data); &#125;, "module1" );&#125;, 3000);// 异步加载 async-module2setTimeout(() =&gt; &#123; require.ensure( [], function () &#123; const asyncModule2 = require("./async-module2"); console.log(asyncModule2.data); &#125;, "module2" );&#125;, 3000);// 引用第三方库// https://github.com/lodash/lodashimport * as _ from "lodash";// https://github.com/axios/axiosimport * as axios from "axios";console.log(_);console.log(axios); 3.配置打包第三方库的规则使用 webpack4 的 splitChunks 可以很容易的做到。 关于splitChunks 的各个参数的用法，可以看我的这篇文章 demo08 关于SplitChunksPlugin 123456789101112splitChunks: &#123; cacheGroups: &#123; vendors: &#123; chunks: "all", // 使用 all 模式 test: /[\\/]node_modules[\\/]/, // 匹配 node_modules 下的模块 name: "vendors", // 包命名，最终的命名要结合 output 的 chunkFilename minChunks: 1, minSize: 30000, priority: 10 // 设置优先级 &#125; &#125; &#125; 4.配置打包异步加载包的规则打包异步加载包123456789101112splitChunks: &#123; cacheGroups: &#123; async: &#123; chunks: "async", minChunks: 1, // 代码块至少被引用的次数 maxInitialRequests: 3, // 设置最大的请求数 minSize: 0, // 设置每个 chunk 最小的大小 (默认30000)，这里设置为 0，以方便测试 automaticNameDelimiter: '~', priority: 9 &#125;, &#125; &#125; 5.完整的 webpack 配置文件1234567891011121314151617181920212223242526272829303132333435363738const path = require("path");module.exports = &#123; mode: 'development', // 使用development模式，方便看到各个包名中的 [name]，以区分各个包，在production模式下，[name]会被转化为0 1 2... entry: &#123; app: "./src/app.js", &#125;, output: &#123; publicPath: __dirname + "/dist/", // 打包后资源文件的引用会基于此路径 path: path.resolve(__dirname, "dist"), // 打包后的输出目录 filename: "[name].[chunkhash].bundle.js", // 每个包包含 chunkhash chunkFilename: "[id].[chunkhash].chunk.js" &#125;, optimization: &#123; runtimeChunk: "single", splitChunks: &#123; cacheGroups: &#123; async: &#123; chunks: "async", minChunks: 1, // 代码块至少被引用的次数 maxInitialRequests: 3, // 设置最大的请求数 minSize: 0, // 设置每个 chunk 最小的大小 (默认30000)，这里设置为 0，以方便测试 automaticNameDelimiter: '~', priority: 9 &#125;, vendors: &#123; chunks: "all", // 使用 all 模式 test: /[\\/]node_modules[\\/]/, // 匹配 node_modules 下的模块 name: "vendors", // 包命名，最终的命名要结合 output 的 chunkFilename minChunks: 1, minSize: 30000, priority: 10 // 设置优先级 &#125; &#125; &#125; &#125;&#125;; 5.执行打包命令 (默认你已经安装了全局 webpack 以及 webpack-cli ) 1webpack 打包成功后，结果输出在 demo09 的 dist 目录下 (注意这里设置 &quot;mode&quot; 为 &quot;development&quot; ) 12345app.226a343cb53e0a689358.chunk.js (app主模块)async~module1.87d116fd41640c30a6b2.chunk.js (async-module1模块)async~module2.65866f4d15253512c981.chunk (async-module2模块)runtime.4e6de616bd3030f8bff8.bundle.js (webpack运行时模块)vendors.a83c085b3a7ac03b1b47.chunk.js (第三方依赖模块) 6.修改程序代码，验证打包结果可以通过修改 app.js 等代码，再次运行 webpack 命令，你会发现，第三方依赖模块的包名没有被改变: vendors.a83c085b3a7ac03b1b47.chunk.js。 在浏览器运行 dist/index.html，打开控制台可以观察异步加载模块的效果。 （备注：runtime.xxxxxxxx.bundle.js模块包含了对异步加载模块的引用逻辑，此外，异步加载引用的相对路径受 output -&gt; publicPath 配置的影响） 7.源码地址demo 代码地址: https://github.com/SimpleCodeCX/simple-webpack-demos/tree/master/demo09-split-vendor-async仓库代码地址(及目录): https://github.com/SimpleCodeCX/simple-webpack-demos]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4实践笔记8 关于SplitChunksPlugin]]></title>
    <url>%2Fblog%2F20190311%2Fca3604dd.html</url>
    <content type="text"><![CDATA[从webpack4开始，用SplitChunksPlugin插件替换了CommonsChunkPlugin插件。相对于CommonsChunkPlugin，SplitChunksPlugin的使用更加方便和清晰。 本系列代码放在 github 上: webpack4系列实践代码如果本系列实践教程对你有帮助,欢迎给个 github star 哦! 1.SplitChunksPlugin 介绍从 webpack4 开始，用 SplitChunksPlugin 插件替换了 CommonsChunkPlugin 插件。相对于 CommonsChunkPlugin ，SplitChunksPlugin 的使用更加方便和清晰。 SplitChunksPlugin 是 webpack4 内置的开箱即用的代码块分离插件，webpack4 会根据你配置好 optimization.splitChunks 规则，进行代码分割，打包成不同的代码块。这样的好处在于避免代码重复引用，减少代码体积，按需加载，从而使浏览器资源加载速度快，并且减少服务器的压力和带宽。 SplitChunksPlugin 文档：https://www.webpackjs.com/plugins/split-chunks-plugin/ 2.splitChunks参数配置 chunks (默认是async) ：initial 、async 和 all minSize (默认是30000)：新代码块最小体积(压缩之前)，单位：字节（b） minChunks（默认是1）：代码块至少被引用的次数 maxInitialRequests (默认是3)：入口处的最大并行请求数 maxAsyncRequests (默认是5)：按需加载时最大的并行请求数 test (默认所有模块): 匹配需要处理的模块, 可以传的值类型: RegExp、String和Function automaticNameDelimiter (默认是’~’): 打包分隔符 priority：缓存组打包的先后优先级 属性优先级 minSize &gt; maxSize &gt; maxAsyncRequests &gt; maxInitialRequest 这里重要介绍一下 chunks 的三个属性 initial、async 和 all。 async 只对对动态（异步）导入的模块进行分离 initial 对所有模块进行分离，如果一个模块既被异步引用，也被同部引用，那么会生成两个包 all 对所有模块进行分离，如果一个模块既被异步引用，也被同部引用，那么只会生成一个共享包 具体可以参考这篇文章: Webpack 4 Mysterious SplitChunks Plugin 3.安装相关依赖 通过 html-webpack-plugin 自动生成 index.html 12npm install -D html-webpack-pluginnpm install -D webpack // html-webpack-plugin 依赖于 webpack 3.目录结构12345678910// `--` 代表目录， `-` 代表文件 --demo08 --src -app1.js -app2.js -module1.js -module2.js -module3.js -index.html -webpack.config.js src/module1.js1export const module1 = 'module1'; src/module2.js1export const module2 = 'module2'; src/module3.js1export const module3 = 'module3'; src/app1.js12345678910111213141516171819202122232425import &#123; module1 &#125; from './module1';import &#123; module2 &#125; from './module2';// module1 module2 属于同步加载console.log('app1: ', module1);console.log('app1: ', module2);// 通过require.ensure对module3.js进行加载调用（此写法在ts模式支持）setTimeout(() =&gt; &#123; require.ensure( [], function () &#123; const module3 = require("./module3"); console.log('app1: ', module3.module3); &#125;, "module3" );&#125;, 3000);// // 异步加载的另一种写法（此写法在ts模式下不支持）// setTimeout(() =&gt; &#123;// import(/* webpackChunkName: 'module3'*/ "./module3").then(function (module3) &#123;// console.log(module3.module3);// &#125;);// &#125;, 3000); src/app2.js12345678import &#123; module1 &#125; from './module1';import &#123; module2 &#125; from './module2';import &#123; module3 &#125; from './module3';// module1 module2 module3 都属于同步加载（注意对比app1.js）console.log('app2: ', module1);console.log('app2: ', module2);console.log('app2: ', module3); 4.编写 webpack 配置文件webpack.config.js 12345678910111213141516171819202122232425262728const path = require("path");module.exports = &#123; mode: 'production' || 'development', entry: &#123; app1: "./src/app1.js", app2: "./src/app2.js" &#125;, output: &#123; publicPath: __dirname + "/dist/", // 打包后资源文件的引用会基于此路径 path: path.resolve(__dirname, "dist"), // 打包后的输出目录 filename: "[name].bundle.js", chunkFilename: "[name].chunk.js" &#125;, optimization: &#123; // runtimeChunk: "single", // 使用single模式，可以避免每一个包都包含webpack的运行文件 splitChunks: &#123; cacheGroups: &#123; modules: &#123; chunks: "async" || "initial" || "all", // 三选一 minChunks: 1, // 代码块至少被引用的次数 maxInitialRequests: 3, // 设置最大的请求数 minSize: 0, // 设置每个chunk最小的大小，只有大于这个值，才会被打包进一个chunk automaticNameDelimiter: '~' &#125; &#125; &#125; &#125;&#125;; 5.执行打包命令 (默认你已经安装了全局 webpack 以及 webpack-cli ) 1webpack 打包成功后，结果输出在 demo08 的dist目录下 在浏览器运行 dist/index.html，打开控制台可以观察异步加载模块的效果。 6.调试参数并验证输出结果这里可以通过修改以上参数（比如 chunks , minChunks , minSize）的值来查看不同的输出结果。 如上 webpack.config.js 配置文件，设置 minSize 为 0 ,以及 minChunks 为 1 以确保满足一个新块的条件。 当设置 chunks 为 async 时webpack只对异步加载的模块进行分离，所以输出结果为：123app1.bundle.jsapp2.bundle.jsmodules~module3.chunk.js (注意以上例子中有两个入口文件 app1.js app2.js) app1.js相关:12app1.bundle.js ( app1 主模块，并且包含 module1.js 和 module2.js)modules~module3.chunk.js app2.js相关:1app2.bundle.js ( app2 主模块，并且包含 module1.js、module2.js 和 module3.js) 当设置 chunks 为 initial 时webpack对所有模块进行分离，如果一个模块既被异步引用，也被同部引用，那么会生成两个包，所以输出结果为：123456app1.bundle.jsapp2.bundle.jsmodule3.chunk.jsmodules~app1.chunk.jsmodules~app1~app2.chunk.jsmodules~app2.chunk.js app1.js相关:1234app1.bundle.js (app1主模块)module3.chunk.js (包含 module3.js 异步加载模块)modules~app1.chunk.js (包含app1独有的模块: 这里暂时没有)modules~app1~app2.chunk.js (包含 module1.js 和 module2.js) app2.js相关:123app2.bundle.js (app2主模块)modules~app2.chunk.js (包含app2独有的模块: 这里是module3.js)modules~app1~app2.chunk.js (包含 module1.js 和 module2.js) 当设置 chunks 为 all 时webpack对所有模块进行分离，如果一个模块既被异步引用，也被同部引用，那么只会生成一个共享包，所以输出结果为：12345app1.bundle.jsapp2.bundle.jsmodules~app1.chunk.jsmodules~app1~app2.chunk.jsmodules~app2~module3.chunk.js app1.js相关:1234app1.bundle.js ( app1 主模块)modules~app1.chunk.js (包含 app1 独有的模块: 这里暂时没有)modules~app1~app2.chunk.js (包含 module1.js 和 module2.js)modules~app2~module3.chunk.js (包含 module3.js 模块,虽然名字没有 app1 ,但是可以通过测试知道，app1 是依赖此模块的，比如把此模块删除，然后在 index.html 中引入上面三个文件，查看控制台就能知道 app1 依赖此模块) app2.js相关:123app2.bundle.js ( app2 主模块)modules~app1~app2.chunk.js (包含 module1.js 和 module2.js)modules~app2~module3.chunk.js (包含 module3.js ) 7.bundle vs chunk不知你注意到没有，以上打包结果中，app1 的主模块（app1.bundle.js）和app2的主模块（app2.bundle.js）的文件名包含的是 bundle，而其他模块包含的是 chunk。 bundle 表明该代码块包含有 webpack 运行时 的代码。而 chunk 则没有。那你可能会问，这样 app1.bundle.js 和 app2.bundle.js 就包含了同样的 webpack 运行时代码，可以把这份 webpack 运行时的代码单独分离出来作为一个单独的块吗？答案是可以的。 在 webpack.config.js 配置文件中添加以下属性即可：1runtimeChunk: &quot;single&quot; 这样在以上 chunks 为 all 的示例中，输出的结果为：123456app1.chunk.jsapp2.chunk.jsmodules~app1.chunk.jsmodules~app1~app2.chunk.jsmodules~app2~module3.chunk.jsruntime.bundle.js ( webpack 运行时模块) 8.源码地址demo 代码地址: https://github.com/SimpleCodeCX/simple-webpack-demos/tree/master/demo08-SplitChunksPlugin仓库代码地址(及目录): https://github.com/SimpleCodeCX/simple-webpack-demos 参考文档： Webpack 4 Mysterious SplitChunks SplitChunksPlugin官方文档]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4 系列实践笔记(7): 自动生成 Html 文件]]></title>
    <url>%2Fblog%2F20190224%2Fe9584fe7.html</url>
    <content type="text"><![CDATA[在之前的 demo 中，执行完 webpack 后要手动把生成的同步模块的 js 包 (或css包) 引入到html中，这样其实是比较繁琐的。尤其是在真正的项目开发中，为了对静态资源或第三方包做长缓存，我们会配置 webpack ，让其生成的每个包的文件名都自动带上该包对应的 chunkhash 值。如果文件内容有改变的话，那么该文件对应的包的 chunkhash 也会改变，这样就导致对应的 html 引用的 url 地址也需要进行相应的修改。因此，我们需要通过 webpack 插件来自动生成 html 以及自动引用相应的 js 包。html-webpack-plugin 插件就能帮你做到。 本系列代码放在 github 上: webpack4系列实践代码如果本系列实践教程对你有帮助,欢迎给个 github star 哦! 1.为什么要自动生成html?在之前的 demo 中，执行完 webpack 后要手动把生成的同步模块的 js 包 (或css包) 引入到html中，这样其实是比较繁琐的。 尤其是在真正的项目开发中，为了对静态资源或第三方包做长缓存，我们会配置 webpack ，让其生成的每个包的文件名都自动带上该包对应的 chunkhash 值。如果文件内容有改变的话，那么该文件对应的包的 chunkhash 也会改变，这样就导致对应的 html 引用的 url 地址也需要进行相应的修改。 因此，我们需要通过 webpack 插件来自动生成 html 以及自动引用相应的 js 包。 html-webpack-plugin 插件就能帮你做到。 2.html-webpack-pluginhtml-webpack-plugin 可以根据你配置的 html 模板，自动生成一个 html 文件，并且引用相关的资源文件。 123456789new HtmlWebpackPlugin(&#123; title: '设置html的title',// 当设置了template选项后，title选项将失效 filename: "index.html", template: "./index.html", minify: &#123; // 压缩选项 collapseWhitespace: true &#125; &#125;), title 设置生成的 html 文件的标题(当设置了template选项后，title选项将失效) filename 生成 html 的文件名 template 指定一个模板文件来生成 html ，可选的模板有 html,jade , ejs 等等，使用自定义模板时，需要安装相对应的 loader 。 inject 配置 &lt;script&gt; (即js包) 标签在 html 中的注入选项：true(默认) | body | head | false true &lt;script&gt; 标签放在 &lt;body&gt; 底部 body 效果与 true 相同 head &lt;script&gt; 标签放在 html 的 &lt;head&gt; 标签内 false 不引用 webpack 生成的 js 文件 favicon 设置 html 文件的 favicon minify (默认false) 对 html 文件进行压缩 hash 在引用 js 或 css 文件的 url 中添加一个唯一的 hash 值，用于避免缓存命中 chunks 默认情况下，html 会引用 webpack 生成的所有同步模块的js文件（即使是多入口），通过此选型可以指定只引入哪些特定入口的文件 excludeChunks 与 chunks 选项相反 官方文档：https://github.com/jantimon/html-webpack-plugin 3.安装相关依赖(注意：html-webpack-plugin 依赖于 webpack，因此需要在项目下安装 webpack)1234npm install -D html-webpack-pluginnpm install -D webpacknpm install -D css-loader // 把 css 转化为 js 模块npm install -D style-loader // 将 css 以 style 节点插入 html 中 4.目录结构12345678// `--` 代表目录， `-` 代表文件 --demo07 --src -app.js -app2.js -style.css --index.html --webpack.config.js src/app.js12345// const css = import('./style.css');window.addEventListener("click", function () &#123; const css = import('./style.css'); console.log(css);&#125;); src/style.js123body&#123; background-color: red;&#125; 5.编写webpack配置文件webpack.config.js 1234567891011121314151617181920212223242526272829303132333435363738const path = require("path");const HtmlWebpackPlugin = require("html-webpack-plugin");module.exports = &#123; entry: &#123; app: "./src/app.js" // app2: "./src/app2.js" &#125;, output: &#123; publicPath: __dirname + "/dist/", // 打包后资源文件的引用会基于此路径 path: path.resolve(__dirname, "dist"), // 打包后的输出目录 filename: "[name].bundle.js" &#125;, module: &#123; rules: [ &#123; test: /\.css$/, // css处理为style标签 use: [ "style-loader", 'css-loader' ] &#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: '设置html的title',// 当设置了template选项后，title选项将失效 filename: "index.html", template: "./index.html", // chunks: ["app"], // entry中的app入口才会被打包 minify: &#123; // 压缩选项 collapseWhitespace: true &#125; &#125;), ]&#125;; 6.执行打包命令 (默认你已经安装了全局 webpack 以及 webpack-cli ) 1webpack 7.验证打包结果在 dist 文件夹中包含 index.html , 并自动引用相应的 js 包。输出结果：1231.bundle.jsapp.bundle.jsindex.html 8.源码地址demo 代码地址: https://github.com/SimpleCodeCX/simple-webpack-demos/tree/master/demo07-html仓库代码地址(及目录): https://github.com/SimpleCodeCX/simple-webpack-demos]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4 系列实践笔记(6): webpack + babel7 + typescript]]></title>
    <url>%2Fblog%2F20190224%2F4af33ce3.html</url>
    <content type="text"><![CDATA[本demo06演示webpack打包babel和typescript，关于babel和typescript的webpack单独打包例&gt;子，请看我之前的demo05和demo06 本系列代码放在 github 上: webpack4系列实践代码如果本系列实践教程对你有帮助,欢迎给个 github star 哦! 1.说明本 demo06 演示 webpack 打包 babel 和 typescript ，关于 babel 和 typescript 的 webpack 单独打包介绍，请看我之前的 demo04 和 demo05 2.关于 @babel 和 typescript 的结合Babel 7 的发布 中有提到 Babel 团队与 Typescript 团队合作，让 Badel 使用 @babel/preset-typescript 来解析转换类型语法。 这篇是 Typescript 团队的相关文章：TypeScript and Babel 7 不过根据文章描述以及我的个人实践，发现当在 Babel 配置文件中通过 @babel/preset-typescript 来编译ts时，useBuiltIns: &quot;usage&quot; 没有生效，导致我需要在 ts 中手动导入整个 @babel/polyfills ，导致整个打包结果比较大。 因此，本 demo06 暂时采用 webpack 结合 ts-loader 的方法来进行 ts 的编译。 3.安装相关依赖@babel 相关12npm install --save-dev @babel/core @babel/preset-envnpm install --save @babel/polyfill //(注意没有-dev ) typescript 相关1npm install --save-dev typescript webpack 相关 12npm install --save-dev babel-loadernpm install --save-dev ts-loader 4.目录结构12345678910// `--` 代表目录， `-` 代表文件 --demo06 --src -app.ts -new-features.ts -User.js -babel.config.js -index.html -tsconfig.json -webpack.config.js src/app.ts 1234567891011121314151617import "@babel/polyfill";import './new-features';import &#123; User &#125; from './User';const user1: User = &#123; name: 'simple', age: '25', hobby: 'play the guitar'&#125;;// 这里参数不够，tsc编译器会报错，webpack编译不通过// const user2: User = &#123;// name: 'simple2',// age: '25'// &#125;;console.log(user1); src/new-features.ts123456789101112131415161718192021222324252627282930// 使用javasript的新特性，比如Promise,WeadMap,Array.prototype.includes等// 不兼容ie 11，因此需要在应用入口(app.ts)导入@babel/polyfill包,在ie 11浏览器进行测试/** * Array.prototype.includes 不兼容ie 11,详见mdn文档 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes * 所以需要通过@babel/polyfill来实现 */const pets = ['cat', 'dog', 'bat'];console.log(pets.includes('cat'));/** * new Set不兼容ie 11,详见mdn文档 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set */const set1 = new Set([1, 2, 3, 4, 5]);console.log(set1.has(1));/** * WeakMap 的 set方法在ie 11下不支持，详见mdn文档 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap */var o1 = &#123;&#125;, o2 = function () &#123; &#125;, o3 = window;let weakmap = new WeakMap();weakmap.set(o1, 1);weakmap.set(o2, 2);weakmap.set(o3, 3);console.log(weakmap.get(o1)); // =&gt; 1 src/User.ts123456789101112// interface typescript 的类型export interface User &#123; name: String, age: String, hobby: String, options?: Object // 可选参数&#125;// 理解一下 webpack 的 Tree Sharking?export interface Animal &#123; name: String&#125; 5.编写 babel 配置文件babel.config.js1234567891011121314151617const presets = [ [ "@babel/env", &#123; targets: &#123; edge: "17", firefox: "60", chrome: "67", safari: "11.1", ie: "11" &#125;, // useBuiltIns: "usage" // 和ts结合的情况，这个属性无效，需要手动import "@babel/polyfill"; &#125;, ],];module.exports = &#123; presets &#125;; 6.编写 tsconfig.json 配置文件tsconfig.json 1234567891011121314151617&#123; "compilerOptions": &#123; "module": "commonjs", "target": "es5", "allowJs": true, "lib": [ "es2018", "dom" ], &#125;, "include": [ "./src/*" ], "exclude": [ "./node_modules" ]&#125; 7.编写 webpack 配置文件webpack.config.js 12345678910111213141516171819202122232425262728293031const path = require("path");module.exports = &#123; mode: 'production' || 'development', entry: &#123; index: "./src/app.ts" &#125;, output: &#123; publicPath: __dirname + "/dist/", // 打包后资源文件的引用会基于此路径 path: path.resolve(__dirname, "dist"), // 打包后的输出目录 filename: "app.bundle.js" &#125;, module: &#123; rules: [ &#123; test: /\.js$/, exclude: /(node_modules)/, use: &#123; loader: "babel-loader" &#125; &#125;, &#123; test: /\.ts?$/, use: 'ts-loader', exclude: /node_modules/ &#125; ] &#125;, resolve: &#123; extensions: ['.ts', '.js'] &#125;&#125; 8.执行打包命令1234&gt;(默认你已经安装了全局 webpack 以及 webpack-cli )webpack 打包成功后，会在 demo06 目录下生成 dist/bundle.js 9.验证打包结果创建 index.html 文件,引用打包生成的文件 (app.bundle.js),分别用 ie , Chrome 浏览器打开，并查看控制台。 输出结果：1234truetrue1&#123;name: &quot;simple&quot;, age: &quot;25&quot;, hobby: &quot;play the guitar&quot;&#125; 10.源码地址demo 代码地址: https://github.com/SimpleCodeCX/simple-webpack-demos/tree/master/demo06-babel-ts仓库代码地址(及目录): https://github.com/SimpleCodeCX/simple-webpack-demos]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4 系列实践笔记(5): webpack + typescript]]></title>
    <url>%2Fblog%2F20190224%2F808417d9.html</url>
    <content type="text"><![CDATA[typescript（简称ts）是javascript的超集，具有类型系统，是可编译的。可以想象得到，在代码运行之前能够进行代码类型检查和编译是多么重要的事儿（就像Java等强类型语言一样）。 本系列代码放在 github 上: webpack4系列实践代码如果本系列实践教程对你有帮助,欢迎给个 github star 哦! 1.关于 typescripttypescript（简称 ts ）是 javascript 的超集，具有类型系统，是可编译的。可以想象得到，在代码运行之前能够进行代码类型检查和编译是多么重要的事儿（就像 Java 等强类型语言一样）。 比如前端框架 @Angular 就默认集成了 ts , 赋予了 @Angular 项目可以编译的功能。 对 ts 不了解的? 先撸一遍 ts 文档?：https://www.tslang.cn/docs/handbook/typescript-in-5-minutes.html ts 默认根据 tsconfig.json 配置文件（很强大）来对 ts 进行编译。 ts 可以单独使用 typescript 编译器编译，也可以在 webpack 中通过 ts-loader 来进行编译（类似于 babel-loader ）。 2.安装相关依赖typescript 相关1npm install --save-dev typescript webpack 相关 1npm install --save-dev ts-loader 3.目录结构12345678// `--` 代表目录， `-` 代表文件 --demo05 --src -app.js -User.js -index.html -tsconfig.json -webpack.config.js src/app.js123456789101112131415import &#123; User &#125; from './User';const user1: User = &#123; name: 'simple', age: '25', hobby: 'play the guitar'&#125;;// 这里参数不够，tsc编译器会报错，webpack编译不通过// const user2: User = &#123;// name: 'simple2',// age: '25'// &#125;;console.log(user1); src/User.ts1234567891011export interface User &#123; name: String, age: String, hobby: String, options?: Object // 可选参数&#125;// 理解一下 webpack 的 Tree Sharking?export interface Animal &#123; name: String&#125; 4.编写 tsconfig.json 配置文件tsconfig.json1234567891011121314151617&#123; "compilerOptions": &#123; "module": "commonjs", "target": "es5", "allowJs": true, "lib": [ "es2018", "dom" ], &#125;, "include": [ "./src/*" ], "exclude": [ "./node_modules" ]&#125; 关于 tsconfig.json 满多学问的，具体的配置根据项目或者参考配置文档来：https://www.tslang.cn/docs/handbook/tsconfig-json.html 也可以找一些开源项目，看一下别人是怎么配置的。 5.编写 webpack 配置文件webpack.config.js123456789101112131415161718192021222324const path = require("path");module.exports = &#123; mode: 'production' || 'development', entry: &#123; index: "./src/app.ts" &#125;, output: &#123; publicPath: __dirname + "/dist/", // 打包后资源文件的引用会基于此路径 path: path.resolve(__dirname, "dist"), // 打包后的输出目录 filename: "bundle.js" &#125;, module: &#123; rules: [ &#123; test: /\.ts?$/, use: 'ts-loader', exclude: /node_modules/ &#125; ] &#125;, resolve: &#123; extensions: ['.ts', '.js'] &#125;&#125; 6.执行打包命令 (默认你已经安装了全局 webpack 以及 webpack-cli ) 1webpack 打包成功后，会在demo05目录下生成 dist/app.bundle.js 7.验证打包结果创建 index.html 文件,引用打包生成的主文件 (app.bundle.js),分别用 ie , Chrome 浏览器打开，并查看控制台。 输出结果：1&#123;name: &quot;simple&quot;, age: &quot;25&quot;, hobby: &quot;play the guitar&quot;&#125; 8.源码地址demo 代码地址: https://github.com/SimpleCodeCX/simple-webpack-demos/tree/master/demo05-ts仓库代码地址(及目录): https://github.com/SimpleCodeCX/simple-webpack-demos]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4 系列实践笔记(4): webpack + babel7]]></title>
    <url>%2Fblog%2F20190224%2Fb77e298c.html</url>
    <content type="text"><![CDATA[babel 7 于2018年8月份发布，在babel 7中，所有官方包更名为以@babel为开头,并且babel 7推荐使用babel.config.js来配置babel 本系列代码放在 github 上: webpack4系列实践代码如果本系列实践教程对你有帮助,欢迎给个 github star 哦! 1.关于 babel 7 版本babel 7 于 2018 年 8 月份发布，在 babel 7 中，所有官方包更名为以 @babel 为开头,并且 babel 7 推荐使用 babel.config.js 来配置 babel 。 关于 babel 7 的重大改变，请参考这篇文章：Babel 7 发布 对 babel 7 不熟的请先撸一下 babel 7 的配置文档：https://babel.docschina.org/docs/en/ 2.安装相关依赖包@babel 相关12npm install --save-dev @babel/core @babel/preset-envnpm install --save @babel/polyfill //(注意没有-dev ) webpack 相关 1npm install --save-dev babel-loader 相关包介绍： @babel/core: babel的核心功能 @babel/preset-env: @babel/preset-env 是一组官方已经配置好的babel plugins预设，省去了自己配置的plugins的麻烦 @babel/polyfill: @babel/polyfills 用来实现所有新的javascript功能，比如 Promise , WeadMap , Array.prototype.includes 等 @babel/polyfills 的三种使用方法 方法1）在代码入口 import &quot;@babel/polyfill&quot;; 方法2）通过配置 &quot;useBuiltIns: &quot;usage&quot;（推荐用法） 方法3）webpack 的 entry 中引入1entry: ["@babel/polyfill","./src/app.js"] // "@babel/polyfill" 需作为第一个 注意，@babel/polyfill 需要打包进代码中，因此需要以 npm install（没有-dev）--save @babel/polyfill 的形式来安装 3.目录结构1234567// `--` 代表目录， `-` 代表文件 --demo04 --src -app.js -babel.config.js -index.html -webpack.config.js src/app.js123456789101112131415161718192021222324252627282930// import "@babel/polyfill";let func = () =&gt; &#123; &#125;;/** * Array.prototype.includes 不兼容 ie 11,详见 mdn 文档 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes * 所以需要通过 @babel/polyfill 来实现 */const pets = ['cat', 'dog', 'bat'];console.log(pets.includes('cat'));/** * new Set不兼容 ie 11,详见 mdn 文档 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set */const set1 = new Set([1, 2, 3, 4, 5]);console.log(set1.has(1));/** * WeakMap 的 set方法在 ie 11 下不支持，详见 mdn 文档 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap */var o1 = &#123;&#125;, o2 = function () &#123; &#125;, o3 = window;let weakmap = new WeakMap();weakmap.set(o1, 1);weakmap.set(o2, 2);weakmap.set(o3, 3);console.log(weakmap.get(o1)); // =&gt; 1 4.编写 babel 配置文件babel.config.js1234567891011121314151617const presets = [ [ "@babel/env", &#123; targets: &#123; // 配置需要兼容的浏览器 edge: "17", firefox: "60", chrome: "67", safari: "11.1", ie: "11" &#125;, useBuiltIns: "usage" &#125;, ],];module.exports = &#123; presets &#125;; useBuiltIns 说明： 通过设置 “@babel/env” 的 “useBuiltIns” 为 “usage” ，省去了手动导入 @babel/polyfill 的过程，而且更重要的是，通过此方式，babel 只会帮你 import 代码中所用到的 polyfill，避免导入整个 @babel/polyfill 包（压缩后将近80k）。 (你可以把 useBuiltIns 注释，并且在 app.js 手动 import &quot;@babel/polyfill&quot; 试试，会导致整个包变大。) 5.编写 webpack 配置文件webpack.config.js12345678910111213141516171819module.exports = &#123; entry: &#123; app: "./src/app.js" &#125;, output: &#123; filename: "bundle.js" &#125;, module: &#123; rules: [ &#123; test: /\.js$/, exclude: /(node_modules)/, use: &#123; loader: "babel-loader" &#125; &#125; ] &#125;&#125;; 6.执行打包命令 (默认你已经安装了全局 webpack 以及 webpack-cli ) 1webpack 打包成功后，会在 demo04 目录下生成 dist/app.bundle.js 7.验证打包结果创建 index.html 文件,引用打包生成的主文件 (app.bundle.js) ,分别用 ie,Chrome 浏览器打开，并查看控制台。 输出结果：123truetrue1 8.源码地址demo 代码地址: https://github.com/SimpleCodeCX/simple-webpack-demos/tree/master/demo04-babel7仓库代码地址(及目录): https://github.com/SimpleCodeCX/simple-webpack-demos]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4 系列实践笔记(3): webpack默认支持各种模块化规范]]></title>
    <url>%2Fblog%2F20190224%2Fa9943a25.html</url>
    <content type="text"><![CDATA[webpack默认支持es6,Commonjs,AMD,umd规范,详见webpack模块文档: https://www.webpackjs.com/concepts/modules/ 本系列代码放在 github 上: webpack4系列实践代码如果本系列实践教程对你有帮助,欢迎给个 github star 哦! 1.模块化规范webpack 默认支持 es6 , Commonjs , AMD , umd 规范。 详见 webpack 模块文档: https://www.webpackjs.com/concepts/modules/ 2.目录结构1234567891011// `--` 代表目录， `-` 代表文件--demo03 --src --lib -hello-amd.js -hello-common.js -hello-es6.js -app.js -babel.config.js -index.html -webpack.config.js hello-amd.js1234567// 使用amd规范来写代码define(function (require, factory) &#123; &apos;use strict&apos;; return function () &#123; console.log(&apos;amd: hello world!&apos;); &#125;&#125;); hello-common.js1234// 使用commonjs规范来写代码module.exports = function () &#123; console.log(&apos;common: hello world!&apos;);&#125;; hello-es6.js1234// 使用es6规范来写代码export default function () &#123; console.log(&apos;es6: hello world!&apos;);&#125; app.js12345678910111213141516/** * webpack支持ES6、CommonJs和AMD规范 */// ES6import es6Hello from &apos;./lib/hello-es6&apos;;es6Hello();// CommonJsvar commonHello = require(&apos;./lib/hello-common&apos;);commonHello();// AMDrequire([&apos;./lib/hello-amd&apos;], function (helloAmd) &#123; helloAmd();&#125;); 3.编写 webpack 配置文件webpack.config.js12345678910111213const path = require(&quot;path&quot;);module.exports = &#123; mode: &apos;production&apos; || &apos;development&apos;, entry: &#123; app: &quot;./src/app.js&quot; &#125;, output: &#123; publicPath: __dirname + &quot;/dist/&quot;, // 打包后资源文件的引用会基于此路径，也可以设置为cdn：https://www.xxx.com(把这句注释掉，运行index.html试试) path: path.resolve(__dirname, &quot;dist&quot;), // 打包文件的输出目录 filename: &quot;app.bundle.js&quot; &#125;&#125;; 4.执行打包命令 (默认你已经安装了全局 webpack 以及 webpack-cli ) 1webpack 打包成功后，打包结果在 dist 文件夹中 5.验证打包结果创建 index.html 文件,引用打包好的主文件 (bundle.js) , 利用 Chrome 浏览器打开，并查看控制台。 输出结果：123es6: hello world!common: hello world!amd: hello world! 6.源码地址demo 代码地址: https://github.com/SimpleCodeCX/simple-webpack-demos/tree/master/demo03-js-module仓库代码地址(及目录): https://github.com/SimpleCodeCX/simple-webpack-demos]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4 系列实践笔记(2): 使用webpack.config.js配置文件]]></title>
    <url>%2Fblog%2F20190224%2F9f220a6b.html</url>
    <content type="text"><![CDATA[webpack是高度可配置的。webpack.config.js是webpack默认的配置文件名，当直接运行webpack，webpack默认根据webpack.config.js进行打包。 本系列代码放在 github 上: webpack4系列实践代码如果本系列实践教程对你有帮助,欢迎给个 github star 哦! 1.关于 webpack 配置文件在 demo01 中，我们通过 webpack xxxxx.js 指定文件名的形式来进行代码打包，其实这样是不方便的。 webpack 是高度可配置的。webpack.config.js 是 webpack 默认的配置文件名，当直接运行 webpack ，webpack 默认根据 webpack.config.js 进行打包。 webpack 有四个核心概念： 入口 (entry) 输出 (output) loader 插件 (plugins) 具体参考 webpack 文档：https://www.webpackjs.com/concepts/ 2.目录结构12345// `--` 代表目录， `-` 代表文件--demo02 --src -hello.js -index.js src/hello.js123export function sayHello() &#123; console.log(&apos;hello world!&apos;);&#125; src/index.js12import &#123; sayHello &#125; from &apos;./hello&apos;;sayHello(); 3.编写 webpack 配置文件webpack.config.js 123456789101112const path = require(&quot;path&quot;);module.exports = &#123; mode: &apos;development&apos;, // 有development模式和production模式 entry: &#123; src: &quot;./src/index.js&quot;, // 入口文件 &#125;, output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), // 打包文件的输出目录 filename: &quot;app.bundle.js&quot; &#125;&#125;; 4.执行打包命令 (默认你已经安装了全局 webpack 以及 webpack-cli ) 1webpack 打包成功后，会在 demo02 目录下生成 dist/app.bundle.js 5.验证打包结果1node dist/app.bundle.js 结果输出：hello world! 6.源码地址demo 代码地址: https://github.com/SimpleCodeCX/simple-webpack-demos/tree/master/demo02-config仓库代码地址(及目录): https://github.com/SimpleCodeCX/simple-webpack-demos]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4 系列实践笔记(1): 最简单的 webpack 零配置]]></title>
    <url>%2Fblog%2F20190224%2Ff0110ca0.html</url>
    <content type="text"><![CDATA[webpack支持零配置打包(无需webpack.config.js配置文件)，我们可以直接运行webpack xxxx.js体验一下 本系列代码放在 github 上: webpack4系列实践代码如果本系列实践教程对你有帮助,欢迎给个 github star 哦! 1.零配置 webpackwebpack4 支持零配置打包(无需 webpack.config.js 配置文件)，首先我们可以直接运行 webpack index.js（入口index.js）进行编译打包。 2.目录结构在 demo01 目录下新建 hello.js 和 index.js 12345// `--` 代表目录， `-` 代表文件--demo01 --src -hello.js -index.js hello.js123export function sayHello() &#123; console.log(&apos;hello world!&apos;);&#125; index.js12import &#123; sayHello &#125; from &apos;./hello&apos;;sayHello(); 3.执行打包命令：webpack (默认你已经安装了全局 webpack 以及 webpack-cli ) 1webpack ./src/index.js 打包成功后，会在 demo01 目录下生成 dist/main.js 4.验证打包结果1node dist/main.js 结果输出：hello world! 5.总结 想了解更多 webpack 的命令? 通过执行 webpack –help 查看 webpack 的参数选项。 打包后为什么是 main.js? 当没有指定 webpack 的输出文件名时，webpack默认以 main 作为包名。 试试这个: webpack ./src/index.js –output ./dist/[name]-[hash].js 为什么 main.js 代码那么复杂? webpack 打包会生成一份 runtime 和 manifest 来管理所有模块的交互，而这份代码也被打包进 main.js 中了。 关于 runtime 和 manifest: https://webpack.docschina.org/concepts/manifest/ 代码被压缩? 在没有指定 webpack 的打包模式时，webpack 默认使用 production 模式进行打包，因此会对代码进行压缩。 试试这个: webpack ./src/index.js –mode development 6.源码地址demo 代码地址: https://github.com/SimpleCodeCX/simple-webpack-demos/tree/master/demo01仓库代码地址(及目录): https://github.com/SimpleCodeCX/simple-webpack-demos]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[@angular前端项目代码优化：构建Api Tree]]></title>
    <url>%2Fblog%2F20181223%2Fe2c87752.html</url>
    <content type="text"><![CDATA[在前端项目的开发过程中，往往后端会给到一份数据接口（本文简称api），为了减少后期的维护以及出错成本，我的考虑是希望能够找到这么一种方法，可以将所有的api以某种方式统一的管理起来，并且很方便的进行维护，比如当后端修改了api名，我可以很快的定位到该api进行修改，或者当后端添加了新的api，我可以很快的知道具体是一个api写漏了。于是，我有了构建Api Tree的想法。 前颜（yan）在前端项目的开发过程中，往往后端会给到一份数据接口（本文简称api），为了减少后期的维护以及出错成本，我的考虑是希望能够找到这么一种方法，可以将所有的api以某种方式统一的管理起来，并且很方便的进行维护，比如当后端修改了api名，我可以很快的定位到该api进行修改，或者当后端添加了新的api，我可以很快的知道具体是一个api写漏了。于是，我有了构建Api Tree的想法。 一、前后端分离（Resful api）在前后端分离的开发模式中，前后端的交互点主要在于各个数据接口，也就是说后端把每个功能封装成了api，供前端调用。举个例子，假设后端提供了关于user的以下3个api：1231 http(s)://www.xxx.com/api/v1/user/&#123; id &#125;2 http(s)://www.xxx.com/api/v1/user/getByName/&#123; name &#125;3 http(s)://www.xxx.com/api/v1/user/getByAge/&#123; age &#125; 对应的api描述如下（为了方便理解，这里只考虑get请求）：1231 获取用户id的用户数据2 获取用户名为name的用户信息 3 获取年龄为age的用户列表 二、在Component中调用api接口获取数据目前各大前端框架比如angular、vue以及react等，都有提供相关HttpClient，用来发起http请求，比如get、post、put、delete等，由于本人比较熟悉angular，下面代码以angular进行举例(其他框架做法类似)，代码统一使用typescript语法。 在app.component.ts中调用api：12345678910111213141516171819202122import &#123; Component &#125; from '@angular/core';import &#123; HttpClient &#125; from '@angular/common/http';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss']&#125;)export class AppComponent &#123; userInfo; constructor(private http: HttpClient) &#123; this.getUserById(1); &#125; async getUserById(userId) &#123; const url = `https://www.xxx.com/api/v1/user/$&#123;userId&#125;`; this.userInfo = await this.http.get(url).toPromise(); &#125;&#125; 三、封装UserHttpService 在项目中，由于多个页面可能需要调用同一个api，为了减少代码的冗余以及方便维护，比较好的方式是将所有的api封装到一个Service中，然后将这个Service实例化成单例模式，为所有的页面提供http服务。 angular提供了依赖注入的功能，可以将Service注入到Module中，并且在Module中的各个Component共享同一个Service，因此不需要手动去实现Service的单例模式。代码如下：user.http.service.ts1234567891011121314151617181920212223242526import &#123; Injectable &#125; from '@angular/core';import &#123; HttpClient &#125; from '@angular/common/http';const HOST_URL = `https://www.xxx.com/api/v1`;@Injectable()export class UserHttpService &#123; constructor(private http: HttpClient) &#123; &#125; async getUserById(userId) &#123; const url = `$&#123;HOST_URL&#125;/user/$&#123;userId&#125;`; return this.http.get(url).toPromise(); &#125; async getUserByName(name) &#123; const url = `$&#123;HOST_URL&#125;/user/getByName/$&#123;name&#125;`; return this.http.get(url).toPromise(); &#125; async getUserByAge(age) &#123; const url = `$&#123;HOST_URL&#125;/user/getByAge/$&#123;age&#125;`; return this.http.get(url).toPromise(); &#125;&#125; app.component.ts1234567891011121314151617181920212223242526272829import &#123; Component &#125; from '@angular/core';import &#123; UserHttpService &#125; from './user.http.service';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss']&#125;)export class AppComponent &#123; constructor(private userHttpService: UserHttpService) &#123; this.getUserById(1); &#125; async getUserById(userId) &#123; const userInfo = await this.userHttpService.getUserById(userId); console.log(userInfo); &#125; async getUserByName(name) &#123; const userInfo = await this.userHttpService.getUserByName(name); console.log(userInfo); &#125; async getUserByAge(age) &#123; const userInfoList = await this.userHttpService.getUserByAge(age); console.log(userInfoList); &#125;&#125; 这样的好处在于:1、团队合作： 可以将前端项目分为HttpService层和Component层，由不同的人进行分开维护2、减少代码的冗余： 在多个Component中调用同一个api时，不需要写多份代码3、降低维护和扩展成本： 当后端增加或修改接口时，由于所有的user api都在UserHttpService里，所以能够很容易的进行接口调整，并且不影响Component层的代码 但以上方案还存在一个缺点，即url使用字符串拼接的形式：1const url = `$&#123;HOST_URL&#125;/user/getByName/$&#123;name&#125;`; 这样容易出现以下问题：1、接口名拼接出错，并且由于是字符串拼接，不会有语法提示（ts）2、没有一份完整的映射后端的api表，出现问题时，不容易排查因此，接下来进入本文的主题：构建Api Tree。 四、手动构建Api Tree什么是Api Tree呢，我把它定义为将所有的api以节点的形式挂在一个树上，最后形成了一棵包含所有api的树形结构。对api tree的构建初步想法（手动构建）如下：1234567891011121314151617181920212223242526272829/** * 手动构建 api tree */const APITREE = &#123; domain1: &#123; api: &#123; v1: &#123; user: &#123; getByName: 'https://www.xxx.com/api/v1/user/getByName', getByAge: 'https://www.xxx.com/api/v1/user/getByAge' &#125;, animal: &#123; getByType: 'https://www.xxx.com/api/v1/animal/getByType', getByAge: 'https://www.xxx.com/api/v1/animal/getByAge' &#125; &#125; &#125; &#125;, domain2: &#123; api: &#123; car: &#123; api1: 'https://xxx.xxx.cn/api/car/api1', api2: 'https://xxx.xxx.cn/api/car/api2' &#125; &#125; &#125;, domain3: &#123;&#125;&#125;;export &#123; APITREE &#125;; 有了api tree，我们就可以采用如下方式来从api树上摘取各个api节点的url，代码如下：12345// 获取url：https://www.xxx.com/api/v1/user/getByNameconst getByNameUrl = APITREE.domain1.api.v1.user.getByName;// 获取url：https://xxx.xxx.cn/api/car/api1const carApi1Url = APITREE.domain2.api.car.api1; 但是以上构建api tree的方式存在两个缺点：1、需要在各个节点手动拼接全路径2、只能摘取子节点的url：getByName和getByAge 无法摘取父节点的url，比如我想获取https://www.xxx.com/api/v1/user，无法通过APITREE.domain1.api.v1.user获取12345678910111213141516const APITREE = &#123; domain1: &#123; api: &#123; v1: &#123; // user为父节点 // 缺点一：无法通过APITREE.domain1.api.v1.user获取 // https://www.xxx.com/api/v1/user user: &#123; // 缺点二：在getByName和getByAge节点中手动写入全路径拼接 getByName: 'https://www.xxx.com/api/v1/user/getByName', getByAge: 'https://www.xxx.com/api/v1/user/getByAge' &#125; &#125; &#125; &#125;&#125;; 五、Api Tree生成器（ApiTreeGenerator）针对手动构建Api Tree的问题，我引入了两个概念：apiTreeConfig（基本配置）和apiTreeGenerator（生成器）。通过apiTreeGenerator对apiTreeConfig进行处理，最终生成真正的apiTree。 1、apiTreeConfig我把它称之为基本配置，apiTreeConfig具有一定的配置规则，要求每个节点名（除了域名）必须与api url中的每一节点名一致，因为apiTreeGenerator是根据apiTreeConfig的各个节点名进行生成，api tree config配置如下：12345678910111213141516171819/** * api tree config * _this可以省略不写，但是不写的话，在ts就没有语法提示 * 子节点getByName,getByAge以及_this可以为任意值，因为将会被apiTreeGenerator重新赋值 */const APITREECONFIG = &#123; api: &#123; v1: &#123; user: &#123; getByName: '', getByAge: '', _this: '' &#125; &#125;, _this: '' &#125; &#125;;export &#123; APITREECONFIG &#125;; 2、apiTreeGenerator我把它称之为生成器，具有如下功能：1） 遍历apiTreeConfig，处理apiTreeConfig的所有子节点，并根据该节点的所有父节点链生成完整的url，并且作为该节点的value，比如： APITREECONFIG.api.v1.user.getByName -&gt; https://www.xxx.com/api/v1/user/getByName2） 遍历apiTreeConfig，处理apiTreeConfig的所有父节点，在每个父节点中添加_this子节点指向父节点的完整url。apiTreeGenerator（生成器）的代码如下：（由于项目中只用到一个后端的数据，这里只实现了单域名的apiTreeGenerator，关于多域名的apiTreeGenerator，大家可以自行修改实现。）123456789101112131415161718192021222324252627282930313233343536373839import &#123; APITREECONFIG &#125; from './api-tree.config';const APITREE = APITREECONFIG;const HOST_URL = `https://www.xxx.com`;/** * 为api node chain添加HOST_URL前缀 */const addHost = (apiNodeChain: string) =&gt; &#123; return apiNodeChain ? `$&#123;HOST_URL&#125;/$&#123;apiNodeChain.replace(/^\//, '')&#125;` : HOST_URL;&#125;;/** * 根据api tree config 生成 api tree： * @param apiTreeConfig api tree config * @param parentApiNodeChain parentApiNode1/parentApiNode2/parentApiNode3 */const apiTreeGenerator = (apiTreeConfig: string | object, parentApiNodeChain?: string) =&gt; &#123; for (const key of Object.keys(apiTreeConfig)) &#123; const apiNode = key; const prefixChain = parentApiNodeChain ? `$&#123;parentApiNodeChain&#125;/` : ''; if (Object.prototype.toString.call(apiTreeConfig[key]) === '[object Object]') &#123; apiTreeGenerator(apiTreeConfig[key], prefixChain + apiNode); &#125; else &#123; apiTreeConfig[key] = parentApiNodeChain ? addHost(prefixChain + apiTreeConfig[key]) : addHost(apiTreeConfig[key]); &#125; &#125; // 创建_this节点 (这里需要放在上面的for之后) apiTreeConfig['_this'] = parentApiNodeChain ? addHost(`$&#123;parentApiNodeChain&#125;`) : addHost('');&#125;;apiTreeGenerator(APITREECONFIG);export &#123; APITREE &#125;; 结果：优化后的UserHttpService代码如下：user.http.service.ts 12345678910111213141516171819202122232425import &#123; Injectable &#125; from '@angular/core';import &#123; HttpClient &#125; from '@angular/common/http';import &#123; APITREE &#125; from './api-tree';@Injectable()export class UserHttpService &#123; constructor(private http: HttpClient) &#123; &#125; async getUserById(userId) &#123; const url = APITREE.api.v1.user._this + '/' + userId; return this.http.get(url).toPromise(); &#125; async getUserByName(name) &#123; const url = APITREE.api.v1.user.getByName + '/' + name; return this.http.get(url).toPromise(); &#125; async getUserByAge(age) &#123; const url = APITREE.api.v1.user.getByAge + '/' + age; return this.http.get(url).toPromise(); &#125;&#125; 六、总结通过api tree，能带来如下好处：1、能够通过树的形式来获取api，关键是有语法提示 APITREE.api.v1.user.getByName2、apiTreeConfig配置文件与后端的api接口一 一对应，方便维护3、当后端修改api名时，apiTreeConfig可以很方便的进行调整 七、demohttps://github.com/SimpleCodeCX/myCode/tree/master/angular/api-tree]]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于依赖注入(typescript)]]></title>
    <url>%2Fblog%2F20181216%2Fa2214845.html</url>
    <content type="text"><![CDATA[依赖注入（DI）和控制反转（IOC）基本是一个意思，因为说起来谁都离不开谁。简单来说，类A依赖类B，但A不控制B的创建和销毁，仅使用B，那么B的控制权则交给A之外处理，这叫控制反转（IOC）。 一、概念：依赖注入（DI）、控制反转（IOC）、IOC容器依赖注入（DI）和控制反转（IOC）基本是一个意思，因为说起来谁都离不开谁。简单来说，类A依赖类B，但A不控制B的创建和销毁，仅使用B，那么B的控制权则交给A之外处理，这叫控制反转（IOC）。由于A依赖于B，因此在A中必然要使用B的instance，我们可以通过A的构造函数将B的实例注入，比如：123456789class B &#123; &#125;class A &#123; constructor(b: B) &#123; console.log(b); &#125;&#125;const b = new B();// 将B的实例注入到a中const a = new A(b); 这个过程叫依赖注入（DI）。 那么什么是IOC Container（容器）？在刚刚的例子中，将B的实例注入到A的构造函数中的这个过程是我们手动操作的，比较麻烦，特别是当类的关系变多变复杂时，这种方式显得很难维护。因此IOC容器就是为了解决这样的问题，IOC容器负责管理对象的生命周期、依赖关系等，实现对象的依赖查找以及依赖注入。 比如Java的Spring以及前端@Angular框架的依赖注入器（DI）就是属于IOC容器。 接下来我将通过代码的形式对比使用依赖注入相比非依赖注入的好处体现在哪。 二、非依赖注入代码我们先来看一段传统的实现代码（非DI）car.ts12345678910111213141516171819202122// 引擎 export class Engine &#123; public cylinders = '引擎发动机1';&#125;// 轮胎export class Tires &#123; public make = '品牌';&#125;export class Car &#123; public engine: Engine; public tires: Tires; public description = 'No DI'; constructor() &#123; this.engine = new Engine(); this.tires = new Tires(); &#125; // Method using the engine and tires drive() &#123; return `$&#123;this.description&#125; car with ` + `$&#123;this.engine.cylinders&#125; cylinders and $&#123;this.tires.make&#125; tires.`; &#125;&#125; 在以上代码中，Car类没有通过第三方容器而是亲自创建了一个引擎（engine）和一些轮胎（tires），这样的代码耦合度比较高，这样会存在以下问题： 问题1：如果有一天对引擎进行升级，代码如下：1234567// 引擎 export class Engine &#123; public cylinders = ''; constructor(_cylinders:string) &#123; this.cylinders = _cylinders; &#125;&#125; 在创建引擎的时候需要传入一个参数，那么这时候就需要修改Car类里的new Engine(parameter)，这样就导致Car类被破坏了，这里请思考一个问题：要怎么做才能使引擎升级的时候不需要修改Car类呢？（答案：DI） 问题2：如果想在Car上使用不同品牌的轮胎，代码如下：1234567891011121314151617// 轮胎export class Tires &#123; public make = '品牌';&#125;export class Tires1 extends Tires &#123; public make = '品牌1';&#125;export class Tires2 extends Tires &#123; public make = '品牌2';&#125;export class Car &#123; //。。。。。。其他代码省略。。。。。。。 public tires: Tires; constructor() &#123; this.tires = new Tires1(); &#125;&#125; 此时又得重新修改Car的代码，这里请思考一个问题：要怎么做才能使Car更换其他不同品牌的轮胎的时候不需要修改Car类呢？（答案：DI） 问题3：如何实现数据共享，比如说车联网，建立了一个Service数据中心，不同的Car通过Service实现数据通信以及数据共享，如果是通过在Car里new Service的方式，是无法实现数据共享和通信的，因为不同Car里的Service不是同一个实例。 这里请思考一个问题：如何实现不同Car的数据通信和共享呢？ 问题4：测试比较难，根本无法测试。 在示例代码中，Car类依赖于Engine类和Tires类，而Engine和Tires又可能各自依赖于其他的类，而其他的类又可能有各自更多的依赖，在这样层层的依赖关系中，由于不能控制Car背后的隐藏依赖，要进行测试是比较难的，或者应该说，这样的代码是根本无法进行测试的。比如说想同时测试不同品牌的轮子的car的性能，因为car里头的new已经写死了，因此无法做到。比如说想同时测试不同参数的引擎的car的性能，因为car里头的new已经写死了，因此无法做到。除非是每次只测试一种情况，下面拿测试不同品牌的轮子来举例：先测试品牌1的轮子：car.ts123456789101112131415161718192021export class Tires &#123; public make = '品牌';&#125;export class Tires1 extends Tires &#123; public make = '品牌1';&#125;export class Tires2 extends Tires &#123; public make = '品牌2';&#125;export class Car &#123; public tires: Tires; public description = 'No DI'; constructor() &#123; // new 一个品牌1的轮子 this.tires = new Tires1(); &#125; // Method using the engine and tires drive() &#123; return `$&#123;this.description&#125; car with ` + ` $&#123;this.tires.make&#125; tires.`; &#125;&#125; 测试程序car.spec.ts 12345678import &#123; Car &#125; from './car.ts';describe('Car类单元测试', function () &#123; it('测试品牌1轮子的Car的驾驶性能', function () &#123; const car = new Car(); car.drive().should.equal('No DI car with 品牌1 tires.'); &#125;)&#125;) 以上代码对轮子品牌1进行测试，输出轮子品牌1的car的驾驶性能。接着对轮子品牌2进行测试：修改Car类,将this.tires = new Tires1();修改为this.tires = new Tires2();此时输出轮子品牌2的car的驾驶性能。 这样的测试效率是很低的，因为每次只能手动的测试一种情况，如果再加上引擎的测试，那多种混合情况就更多了，根本就不能做到自动测试，所谓的自动测试，是一次性将所有的情况都写到一个单元测试里，一次运行，所有情况都会被测试到，当测试通过了，那么就说明代码达到了预期。 针对以上问题，我们来看看使用DI的好处。 三、使用依赖注入（DI）接下来将演示使用DI来解决以上的4个问题。先看使用DI实现的car.ts代码：car.ts12345678910111213141516171819202122export class Engine &#123; public cylinders = '引擎发动机1';&#125;export class Tires &#123; public make = '品牌';&#125;export class Tires1 extends Tires &#123; public make = '品牌1';&#125;export class Tires2 extends Tires &#123; public make = '品牌2';&#125;export class Car &#123; public description = 'DI'; // 通过构造函数注入Engine和Tires constructor(public engine: Engine, public tires: Tires) &#123;&#125; // Method using the engine and tires drive() &#123; return `$&#123;this.description&#125; car with ` + `$&#123;this.engine.cylinders&#125; cylinders and $&#123;this.tires.make&#125; tires.`; &#125;&#125; 在以上代码中，通过往构造函数中传入engine和tires来创建Car，Car类不再亲自创建engine和tires，而是消费它们，此时最大的好处就是engine和tires与Car解除了强耦的关系。在new Car的时候，可以传入任何类型的Engine和Tires，即 let car = new Car(new Engine(),new Tires()); 解决问题1：如果有一天对引擎进行升级，代码如下：123456export class Engine &#123; public cylinders = ''; constructor(_cylinders:string) &#123; this.cylinders = _cylinders; &#125;&#125; 在创建引擎的时候需要传入一个参数，这时候不需要修改Car类，只需要修改主程序即可： 主程序代码： 1234main()&#123; const car = new Car(new Engine('引擎启动机2'), new Tires1()); car.drive();&#125; 解决问题2：如果想在Car上使用不同品牌的轮胎，代码如下： 12345678910111213export class Tires &#123; public make = '品牌';&#125;export class Tire1 extends Tires &#123; public make = '品牌1';&#125;export class Tire2 extends Tires &#123; public make = '品牌2';&#125;export class Car &#123; //。。。。。。其他代码省略。。。。。。。 constructor(public engine: Engine, public tires: Tires) &#123;&#125; &#125; 此时不需要修改Car类，只需要修改主程序即可：主程序代码：12345main()&#123; // 使用品牌2的轮胎 const car = new Car(new Engine('引擎启动机2'), new Tires2()); car.drive();&#125; 解决问题3：如何实现数据共享，比如说车联网，建立一个Service数据中心（就像angular的Service层，可以给多个component共享），不同的Car通过Service实现数据通信以及数据共享。代码如下：Service.ts1234567891011export class Service &#123; public data = ''; // 向Service存数据 setData(_data: string) &#123; this.data = _data; &#125; // 从Service中取数据 getData() &#123; return this.data; &#125;&#125; car.ts1234567891011export class Car &#123; constructor(public service: Service) &#123; &#125; // 向Service存数据 setDataToService(_data: string) &#123; this.service.setData(_data); &#125; // 从Service中取数据 getDataFromService() &#123; return this.service.getData(); &#125;&#125; 此时主程序如下：主程序代码：12345678910main()&#123; // 创建一个共享服务中心Service const shareService = new Service(); const car1 = new Car(shareService); const car2 = new Car(shareService); // car1向服务中心存数据 car1.setDataToService('this data is from car1.'); // car2从服务中心取数据 car2.getDataFromService();&#125; 解决问题4：测试用例 在示例代码中，Car类依赖于Engine类和Tires类，而Engine和Tires又可能各自依赖于其他的类，而其他的类又可能有各自的依赖，在这样层层的依赖关系中，使用DI的代码测试是比较简单的。测试程序如下：测试程序 car.spec.ts 1234567891011121314151617181920212223242526import &#123; Car,Engine,Tires1, Tires2&#125; from './car.ts';// 测试程序入口describe('Car类单元测试', function () &#123; const engine1 = new Engine('引擎发动机1'); const engine2 = new Engine('引擎发动机2'); const tires1 = new Tires1(); const tires2 = new Tires2(); it('测试引擎1 轮胎品牌1', function () &#123; const car = new Car(engine1, tires1); car.drive().should.equal('DI car with 引擎发动机1 cylinders and 品牌1 tires.'); &#125;); it('测试引擎1 轮胎品牌2', function () &#123; const car = new Car(engine1, tires2); car.drive().should.equal('DI car with 引擎发动机1 cylinders and 品牌2 tires.'); &#125;); it('测试引擎2 轮胎品牌1', function () &#123; const car = new Car(engine2, tires1); car.drive().should.equal('DI car with 引擎发动机2 cylinders and 品牌1 tires.'); &#125;); it('测试引擎2 轮胎品牌2', function () &#123; const car = new Car(engine2, tires2); car.drive().should.equal('DI car with 引擎发动机2 cylinders and 品牌2 tires.'); &#125;); &#125;) 此时觉得很棒有木有，自动测试的思想就是这样的，将所有的情况的代码都配置好，一次运行，所有的情况都可以测试到。 至此，如果看懂以上的话，DI的思想以及为什么要用DI就应该可以理解了。]]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何解决前端跨域问题]]></title>
    <url>%2Fblog%2F20181209%2F8d45a80b.html</url>
    <content type="text"><![CDATA[跨域主要是浏览器限制的，浏览器要求请求的url地址与当前的页面的url地址处于域名、端口号、协议一致，如果出现其中的一项不一致，则跨域。 为什么会跨域?​ 跨域主要是浏览器限制的，浏览器要求请求的url地址与当前的页面的url地址处于域名、端口号、协议一致，如果出现其中的一项不一致，则跨域。 ​ 因为我现在做的项目是前后端分离的，所以会出现这个问题。 ​ 先说一下我的服务器环境：centos7 + nginx，假设我的前端项目部署在服务器的http://100.100.100.100:80上，而后端项目部署在http://100.100.100.100:8080上，那么此时前端项目（80端口）请求服务器接口（8080端口）时，浏览器就会提示跨域，导致请求受限制。 解决方式： 方法一：通过设置后端的cors允许跨域这种方式比较简单,需要配合后端实现,通过在后端设置cors允许跨域，可以指定ip,也可以用”*“允许全部.以下是在koa2中允许跨域代码（不同的服务器框架或语言的跨域配置类似） 12345678910app.use(cors(&#123; origin: function (ctx) &#123; return &quot;*&quot;; &#125;, exposeHeaders: [&apos;WWW-Authenticate&apos;, &apos;Server-Authorization&apos;], maxAge: 5, credentials: true, allowMethods: [&apos;GET&apos;, &apos;POST&apos;, &apos;DELETE&apos;, &apos;PUT&apos;], allowHeaders: [&apos;Content-Type&apos;, &apos;Authorization&apos;, &apos;Accept&apos;, &apos;accesstoken&apos;],&#125;)) 方法二：通过JsonPJsonP的原理大概就是，利用浏览器对script加载完自动执行的特新来实现的。 比如前端有一段代码： 12345&lt;script&gt; function handle(data)&#123; console.log(data); &#125;&lt;/script&gt; 假设服务器接口名为 http://100.100.100.100/getData该接口返回一个文件，文件内容为： 1handle(&apos;数据。数据。数据。&apos;); 那么请看以下前端代码： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script&gt; function handle(data)&#123; console.log(data); &#125; &lt;/script&gt; &lt;script&gt; var url = &quot;http://100.100.100.100/getData&quot;; var script = document.createElement(&apos;script&apos;); script.setAttribute(&apos;src&apos;, url); document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; ​ 当第二个script里的代码执行完之后，第一个script里的handle就会被调用，此时输出&#39;数据。数据。数据。&#39;。 ​ 采用JsonP的过程比较繁琐，需要客户端和服务器端两端的同时配合，因此需要特别处理的接口可以使用，一般传统的后台接口不会采用这种方式进行跨域。 方法三：通过nginx反向代理采用nginx反向代理能很好的实现跨域，目前我的项目就是采用的这种方式。 ​ 先做以下假设： ​ 我的服务器域名为 www.simple.com ip为：100.100.100.100 ​ 前端项目部署在100.100.100.100:80 ​ 后端项目部署在100.100.100.100:8080 ​ 那么为了实现跨域，我可以这么配置我的nginx。 ​ https://www.simple.com =&gt; 100.100.100.100:80 ​ https://www.simple.com/api =&gt; 100.100.100.100:8080 ​ 当前端项目要请求接口的时候，可以通过https://www.simple.com/api进行请求，完美跨域。]]></content>
      <categories>
        <category>前端跨域</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于js正则表达式的贪婪和懒惰模式]]></title>
    <url>%2Fblog%2F20181130%2F3ba3fd82.html</url>
    <content type="text"><![CDATA[正则表达式的量词有：* + ? {}量词默认是贪婪模式，当在量词后面加上一个问号?时，就变成了懒惰模式。 1、量词 正则表达式的量词有：* + ? {} * : 匹配0次到多次 + : 匹配1次到多次 ? : 匹配0次或1次 {n,m} : 匹配至少n次，最多m次 {n} : 匹配n次 {0,} : 等价于* {1,} : 等价于+ {0,1} : 等价于? 量词默认是贪婪模式，当在量词后面加上一个问号?时，就变成了懒惰模式。 2、贪婪模式 使用量词(* + ? {})时，默认为贪婪模式。 贪婪模式尝试匹配最多字符，具体怎么做呢？ 首先尝试匹配整个字符串，如果匹配不成功，就去掉最后一个字符，并再次尝试匹配，直到匹配成功或者字符串为空为止。 举个例子： 1234demo1.jslet str1 = 'xxx123xxxxxxxxxx123xxx';let regex1 = /.*123/; console.log(regex1.exec(str1)[0]); 输出结果：’xxx123xxxxxxxxxx123’ 分析demo1代码,由于使用量词，因此默认为贪婪模式，会尝试匹配最多字符，即匹配全部字符 第1次尝试：’xxx123xxxxxxxxxx123xxx’ 与 /.123/ 不匹配 第2次尝试：’xxx123xxxxxxxxxx123xx’ 与 /.123/ 不匹配 第3次尝试：’xxx123xxxxxxxxxx123x’ 与 /.123/ 不匹配 第4次尝试：’xxx123xxxxxxxxxx123’ 与 /.*123/ 匹配 因此匹配结果为：’xxx123xxxxxxxxxx123’ 3、懒惰模式 在量词(* + ? {})后直接加上?时，即为懒惰模式。 懒惰模式尝试匹配最少字符，具体怎么做呢？ 首先尝试匹配空字符串，如果匹配不成功，就多读取一个字符，并再次尝试匹配，直到匹配成功或者整个字符串读取完为止。 看下面例子： 1234demo2.jslet str2 = "xxx123xxxxxxxxxx123xxx";let regex2 = /3*?/;console.log(regex2.exec(str2)[0]); 输出结果：’’ 分析demo2代码,由于在量词后加入了?，因此采用懒惰模式，会尝试匹配最少字符。 第1次尝试：’’ 与 /3?/ 匹配 因此匹配结果为：’’]]></content>
      <categories>
        <category>正则</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于js对观察订阅者模式的一些体会和应用场景]]></title>
    <url>%2Fblog%2F20181124%2F19bf8033.html</url>
    <content type="text"><![CDATA[场景：在项目中，不同页面的header样式一样，只有title文字不一样，比如page1显示的titile是’page1’，而page2显示的titile是’page2’,于是我把header做成了一个组件，而每个页面也是一个组件，因此通过SimpleObservable就可以实现组件与组件间的间接单向通信，即观察者（observer）监听被观察者（observable），被观察者触发观察者。 1、自己实现一个简单版的rxjs：SimpleObservable1234567891011121314151617181920212223242526SimpleObservable.tsclass SimpleObservable &#123; private observer: Array&lt;Function&gt;; constructor() &#123; this.observer = []; &#125; subscribe(_observer: Function) &#123; this.observer.push(_observer); let _index = this.observer.length - 1; let that = this; return &#123; _index: _index, unsubscribe: function () &#123; console.log("before:unsubscribe:", that.observer); that.observer.splice(this._index, 1); console.log("after :unsubscribe:", that.observer); &#125; &#125;; &#125; next(_data: any) &#123; for (let i = 0, len = this.observer.length; i &lt; len; i++) &#123; this.observer[i](_data); &#125; &#125;&#125;export default SimpleObservable; 2、实现监听场景：在项目中，不同页面的header样式一样，只有title文字不一样，比如page1显示的titile是’page1’，而page2显示的titile是’page2’,于是我把header做成了一个组件，而每个页面也是一个组件，因此通过SimpleObservable就可以实现组件与组件间的间接单向通信，即观察者（observer）监听被观察者（observable），被观察者触发观察者。 （备注：以下用ts语法，可以通过tsc编译生成对应js，再运行） 大致代码如下： demo1 1234567891011121314151617demo1.tsimport SimpleObservable from './SimpleObservable';let subscriptions=[];let headerTitleObservable = new SimpleObservable();let headerTitle_subscriptsion = headerTitleObservable .subscribe(_title =&gt; &#123; console.log(`the header title is change to$&#123;_title &#125;`); &#125;);subscriptions.push(headerTitle_subscriptsion );// 触发this.headerTitleObservable.next('page1');// 在组件生命周期结束时，清除所有observerssubscriptions.forEach(subscription =&gt; &#123; subscription.unsubscribe(); &#125;); 2、解除两个类的强耦合状态使用观察订阅者模式，有时候能解除两个类的强耦合状态，比如，在我的项目中，我写了一个http拦截器httpInterceptor,用来过滤每一次http请求和响应，比如统一加access_token header，统一出错处理啊等等，我的httpInterceptor其中的一个功能，就是从服务器返回的响应头中检测登录状态是否已经失效或access_token是否已经过期，当检测到登录失效时，要在页面中弹出一个登录modal框（loginModalComponent），提醒用户重新登录。大致的代码如下： (备注：以下采用ts语法，为了使理解起来更加容易，没有使用ts的依赖注入等特性) 未使用观察者模式： demo2 12345678910111213141516171819202122232425262728293031demo2.ts/** * 这里模拟了一个登录modal组件 */class LoginModalComponent &#123; constructor() &#123; &#125; open() &#123; console.log('##检测到access_token已经过期，打开login模态框##'); console.log('请输入账号和密码,点击登录'); &#125;&#125;/** * 这里模拟了一个http拦截器 */class HttpInterceptor &#123; loginModalComponent: LoginModalComponent = new LoginModalComponent();; constructor() &#123; &#125; handleHttpRes() &#123; if (this.checkLoginInvalid) &#123; this.loginModalComponent.open(); &#125; &#125; // 检查登录是否失效 checkLoginInvalid() &#123; return true; &#125;&#125;let httpInterceptor = new HttpInterceptor();httpInterceptor.handleHttpRes(); 以上示例代码是未使用观察者模式的情况下，需要在HttpInterceptor里new LoginModalComponent,从而导致HttpInterceptor和LoginModalComponent处于强耦合的状态，但是这样不符合HttpInterceptor拦截器的思想，因为HttpInterceptor拦截器是不应该和组件相关的东西进行耦合的，因此，采用观察者模式进行改进. 代码如下： demo3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101demo3.tsclass SimpleObservable &#123; private observer: Array&lt;Function&gt;; constructor() &#123; this.observer = []; &#125; subscribe(_observer: Function) &#123; this.observer.push(_observer); let _index = this.observer.length - 1; let that = this; return &#123; _index: _index, unsubscribe: function () &#123; console.log("before:unsubscribe:", that.observer); that.observer.splice(this._index, 1); console.log("after :unsubscribe:", that.observer); &#125; &#125;; &#125; next(_data: any) &#123; for (let i = 0, len = this.observer.length; i &lt; len; i++) &#123; this.observer[i](_data); &#125; &#125;&#125;/** * 这里模拟了一个登录modal组件 */class LoginModalComponent &#123; constructor() &#123; &#125; open() &#123; console.log('##检测到access_token已经过期，打开login模态框##'); console.log('请输入账号和密码,点击登录'); &#125;&#125;/** * 通过一个service来作为中间者，从而解除HttpInterceptor和LoginModalComponent强耦合状态。 */class HttpStatusService &#123; login_invalid_observable = new SimpleObservable(); constructor() &#123; &#125; getLoginInvalidObservable() &#123; return this.login_invalid_observable; &#125; triggerLoginInvalidObservable() &#123; this.login_invalid_observable.next('access_token is invalid.') &#125;&#125;/** * 创建一个HttpStatusService的实例，全局可用，实际的做法是采用ts的依赖注入 */let httpStatusService: HttpStatusService = new HttpStatusService();/** * 这里模拟了一个http拦截器 */class HttpInterceptor &#123; constructor() &#123; &#125; handleHttpRes() &#123; if (this.checkLoginInvalid) &#123; httpStatusService.triggerLoginInvalidObservable(); &#125; &#125; // 模拟一个登录失败的状态，实际的情况是，拦截到http请求的服务器响应信息 checkLoginInvalid() &#123; return true; &#125;&#125;/** * AppComponent,一个页面跟组件 */class AppComponent &#123; loginModalComponent: LoginModalComponent = new LoginModalComponent(); subscriptions: Array&lt;any&gt; = []; constructor() &#123; this.init(); &#125; init() &#123; let subscription1 = httpStatusService.getLoginInvalidObservable().subscribe((err_msg) =&gt; &#123; this.loginModalComponent.open(); &#125;); this.subscriptions.push(subscription1); &#125; onDestroy() &#123; this.subscriptions.forEach(subscription =&gt; &#123; subscription.unsubscribe(); &#125;); &#125;&#125;let appComponent = new AppComponent();/** * 此时appComponent已经在监听httpStatusService里的login_invalid_observable */let httpInterceptor = new HttpInterceptor();httpInterceptor.handleHttpRes();appComponent.onDestroy();]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于js（es5）如何优雅地创建对象]]></title>
    <url>%2Fblog%2F20181115%2F7df91c4c.html</url>
    <content type="text"><![CDATA[对象（Object Oriented，OO）对于基于类的语言来说是再普通不过的一个概念 了，比如C++，Java等等。而在es5（以下js指es5）中，由于没有类的概念，因此它的对象与其他基于类的语言的对象是不同的。因此在js中，关于对象的创建方法也有所不一样。本文介绍各种创建js对象的方法，以及优缺点。 一、前颜（yan）对象（Object Oriented，OO）对于基于类的语言来说是再普通不过的一个概念 了，比如C++，Java等等。而在es5（以下js指es5）中，由于没有类的概念，因此它的对象与其他基于类的语言的对象是不同的。因此在js中，关于对象的创建方法也有所不一样。本文介绍各种创建js对象的方法，以及优缺点。 二、通过Object创建对象123456var cat = new Object();cat.name = 'kiki1';cat.age = 1;cat.speak = function () &#123; console.log('Hello I am ', this.name);&#125; 缺点：当需要创建多个相似对象时，会产生大量的重复代码，比如这时候我想再创建一个cat2，这时就得重复一遍以上代码。123456var cat2 = new Object();cat2.name = 'kiki2';cat2.age = 2;cat2.speak = function () &#123; console.log('Hello I am ', this.name);&#125; 三、通过对象字面量语法对象1234567var cat = &#123; name: 'kiki1', age: 1, speak: function () &#123; console.log('Hello I am ', this.name); &#125;&#125; 特点：通过此方法来创建对象相比Object创建对象代码简洁了很多缺点：与通过Object创建对象的缺点一致 为了解决以上问题，以下模式来了。 四、通过工厂模式创建对象123456789101112131415function createCat(name, age) &#123; var o = new Object(); o.name = name; o.age = age; o.speak = function () &#123; console.log('Hello I am ', this.name); &#125; return o;&#125;var cat1=createCat('kiki1',1);var cat2=createCat('kiki2',2);cat1.speak(); //Hello I am kiki1cat2.speak(); //Hello I am kiki2 特点：通过工厂模式创建对象，可以解决创建多个相似对象的问题。缺点：无法识别对象，即无法知道一个对象的类型。 五、通过构造函数模式创建对象通过构造函数模式创建对象，能够很好的解决工厂模式创建对象的问题。 1234567891011121314151617181920function Cat(name, age) &#123; this.name = name; this.age = age; this.speak = function () &#123; console.log('Hello I am ', this.name); &#125;&#125;let cat1 = new Cat('kiki1', 1);let cat2 = new Cat('kiki2', 2);cat1.speak(); //Hello I am kiki1cat2.speak(); //Hello I am kiki2// 检测对象类型console.log(cat1 instanceof Cat); // trueconsole.log(cat2 instanceof Cat); // true// 不同实例上的同名函数是不相等console.log(cat1.speak == cat2.speak); // false 特点：1、通过new Cat来创建实例2、可以通过instanceof来检测对象类型缺点：使用构造函数的缺点在于，每个方法都会在实例上重新创建一遍，所以不同实例上的同名函数是不相等的,即无法共享方法。比如上面的例子中的cat1.speak和cat2.speak是不相等的。 为了解决此缺点，请看原型模式。 六、原型模式123456789101112131415161718function Cat() &#123; &#125;Cat.prototype.name = 'kiki1';Cat.prototype.age = 1;Cat.prototype.speak = function () &#123; console.log('Hello I am ', this.name);&#125;Cat.prototype.data = [1, 2];let cat1 = new Cat();let cat2 = new Cat();console.log(cat1.speak == cat2.speak); // true// 引用类型属性，不同实例之间互相影响console.log(cat2.data); // [1,2]cat1.data.push(3);console.log(cat1.data); // [1,2,3]console.log(cat2.data); // [1,2,3] 特点：共享方法，比如上面的例子中，cat1.speak和cat2.speak是相等的。缺点：由于引用类型的属性也是共享的，因此不同实例之间会互相影响 六、组合模式组合模式：即构造函数模式+原型模式。采用组合模式可以解决构造函数模式和原型模式的问题，又拥有构造函数和原型模式的特点，集两种模式之长。通过构造函数模式定义实例属性，通过原型模式定义共享方法和共享属性。 12345678910111213141516function Cat(name, age, data) &#123; this.name = name; this.age = age; this.data = data;&#125;Cat.prototype.speak = function () &#123; console.log('Hello I am ', this.name);&#125;let cat1 = new Cat('kiki1', 1, [1, 2, 3]);let cat2 = new Cat('kiki2', 2, [3, 4, 5]);console.log(cat1.speak == cat2.speak); // trueconsole.log(cat1.data); // [1,2,3]console.log(cat2.data); // [3,4,5] 综上对比，组合模式是最优雅的创建对象的方式。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于mocha、should.js、karma、travis ci实现前端自动化持续测试]]></title>
    <url>%2Fblog%2F20181108%2F16dc22b.html</url>
    <content type="text"><![CDATA[首先你觉得测试重要吗？为什么重要？ 这里举个例子，假如你写了一个逻辑稍微比较复杂的函数，这个函数被很多地方调用到，那么当过了N多天之后，你可能快要忘记这里面的逻辑了，此时你可能出于某种原因需要为这个函数增加一些功能，修改这个函数的代码，那么你要怎么做才能做到修改后不影响其他的调用者呢，或者说，你要怎么做，才能快速的知道哪些地方受影响，哪些地方不受影响呢？ 前颜（yan）首先你觉得测试重要吗？为什么重要？ 这里举个例子，假如你写了一个逻辑稍微比较复杂的函数，这个函数被很多地方调用到，那么当过了N多天之后，你可能快要忘记这里面的逻辑了，此时你可能出于某种原因需要为这个函数增加一些功能，修改这个函数的代码，那么你要怎么做才能做到修改后不影响其他的调用者呢，或者说，你要怎么做，才能快速的知道哪些地方受影响，哪些地方不受影响呢？ 很明显，答案就是：跑测试用例 对于单元测试，我能想到的好处有： 改进代码设计，提高代码质量：单元测试会强制你对代码进行合理的设计，解耦，写出可测试的代码 允许重构，你可以放心的对代码进行修改，因为你有测试用例来确保你的代码能够按符合预期要求 快速定位bug 既然单元测试这么重要，那么就应该好好重视起来。 前端测试框架和库目前前端测试框架和库主要有assert、should.js、expect、chai、mocha、jasmine、karma以及travis ci等等。 其中assert、should.js、expect、chai属于断言库，实现对js代码进行断言测试。 ​而mocha、jasmine属于测试框架，测试框架通过使用断言库对js代码进行测试，生成测试报告，除此之外，测试框架还提供了各种生命周期。 ​karma则属于测试工具，能够模拟各种环境来运行你的测试代码，比如Chrome，Firefox，mobile等等。 ​重点要介绍的是travis ci，是一个远程免费的持续集成（CI）服务，你可以通过配置绑定你github上的项目，并且配置运行环境，实现只要github上有代码更新，travis就会自动运行构建和测试，并反馈运行结果。 ​下面对不同断言库进行简单的介绍： ​断言库（主要实现对代码进行测试） assert ：TDD风格断言，是nodejs的一个断言测试模块，提供的api不是很多 1assert.equal(foo, 'foo'); should.jd：BDD风格断言库，should相对于assert有比较丰富的api，并且其语法非常的语义化 123foo.should.be(); bar.should.have();foo.should.bot.be(); expect：BDD风格断言，语法和should.js类似 1234expect(foo).to.be();expect(foo).to.eql();expect(foo).to.be.a();expect(foo).not.to.be.an(); chai：支持BDD/TDD双模式，同时支持should/expect/assert三种风格的断言库，还有强大的插件机制 1234567891011shouldchai.should();foo.should.be.a('string');expectvar expect = chai.expect;expect(foo).to.be.a('string');assertvar assert = chai.assert;assert.typeOf(foo, 'string'); 接下来，我将使用mocha、should.js、karma、travis ci实现几个前端js自动化持续测试的demo。大家可以克隆相应的代码下来对应着看，由于篇幅有限，下面只讲关键点。 demo1(mocha+should.js)特点：直接使用mocha和should.js来跑测试用例。 代码地址：https://github.com/SimpleCodeCX/myCode/tree/master/test/demo1 关键点说明： 1 下载相关依赖（mocha和should.js） 12npm instal -g mocha （全局）npm install --save-dev should 2 添加主功能（待测试）代码 12345#src/main.jsfunction add(x, y) &#123; return x + y;&#125;module.exports = add; 3 添加测试用例 12345678#test/test.jsvar add = require('../src/main')describe('add', function () &#123; it('8 + 8 = 16', function () &#123; add(8, 8).should.equal(16); &#125;)&#125;) 4 配置mocha.opts 12#test/mocha.opts--require should 关于mocha.opts的更多配置（代替命令行参数）：https://mochajs.org/#mochaopts 5 运行 1mocha 输出测试结果 123456&gt;mochaadd √ 8 + 8 = 16 1 passing (10ms) demo2(mocha+should.js+karma)特点： 通过karma调用mocha测试框架来进行代码测试 优点在于karma能模拟浏览器比如Chrome、Firefox来运行测试代码 代码地址：https://github.com/SimpleCodeCX/myCode/tree/master/test/demo2 关键点说明： 1 下载相关依赖（mocha、should.js和karma） 12345npm install --save-dev mocha（demo1使用的是全局mocha，这里是karma调用mocha）npm install --save-dev shouldnpm install --save-dev karmanpm install --save-dev karma-chrome-launchernpm install --save-dev karma-mocha 2 添加主功能（待测试）代码 12345#src/main.js(注意和demo1的区别)function add(x, y) &#123; return x + y;&#125; 3 添加测试用例 1234567#test/test.js(注意和demo1的区别)describe('add', function () &#123; it('8 + 8 = 16', function () &#123; add(8, 8).should.equal(16); &#125;)&#125;) 4 配置karma（karma.conf.js） 运行 karma init，按提示操作。 12345678910111213141516171819202122232425262728293031Which testing framework do you want to use ?Press tab to list possible options. Enter to move to the next question.&gt; mochaDo you want to use Require.js ?This will add Require.js plugin.Press tab to list possible options. Enter to move to the next question.&gt; noDo you want to capture any browsers automatically ?Press tab to list possible options. Enter empty string to move to the next question.&gt; Chrome&gt;What is the location of your source and test files ?You can use glob patterns, eg. &quot;js/*.js&quot; or &quot;test/**/*Spec.js&quot;.Enter empty string to move to the next question.&gt; test/**/*.js&gt;Should any of the files included by the previous patterns be excluded ?You can use glob patterns, eg. &quot;**/*.swp&quot;.Enter empty string to move to the next question.&gt;Do you want Karma to watch all the files and run the tests on change ?Press tab to list possible options.&gt; yesConfig file generated at &quot;...\demo2\karma.conf.js&quot;. 然后在karma.conf.js中的files添加相关的依赖模块：12345files: [ &apos;node_modules/should/should.js&apos;, &apos;test/**/*.js&apos;, &apos;src/**/*.js&apos; ] 关于karma的更多配置：http://karma-runner.github.io/3.0/config/configuration-file.html 5 运行 1karma start karma会运行chrome浏览器，并且输出测试结果 1234567&gt;karma start08 11 2018 21:01:34.765:WARN [karma]: No captured browser, open http://localhost:9876/08 11 2018 21:01:34.775:INFO [karma]: Karma v1.7.1 server started at http://0.0.0.0:9876/08 11 2018 21:01:34.775:INFO [launcher]: Launching browser Chrome with unlimited concurrency08 11 2018 21:01:34.785:INFO [launcher]: Starting browser Chrome08 11 2018 21:01:37.456:INFO [Chrome 70.0.3538 (Windows 7.0.0)]: Connected on socket h9aSRbkdzZNTgb2dAAAA with id 46125810Chrome 70.0.3538 (Windows 7.0.0): Executed 1 of 1 SUCCESS (0.007 secs / 0.002 secs) demo3(mocha+should.js+karma+travis)代码地址：https://github.com/SimpleCodeCX/myCode/tree/master/test/demo3 1 复制demo2的工程作为demo3 2 在github上创建一个新工程demo3，并关联本地仓库 1git remote add origin git@github.com:SimpleCodeCX/demo3.git 3 使用github账号登录travis官网，同步并激活监听github上的demo3项目 参考文章：http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html 4 配置travis（.travis.yml） 在demo3的根目录下新建.travis.yml文件，并做如下配置：123456789language: node_jsnode_js: - &quot;8&quot;script: karma start --single-runbefore_install: - npm install - export CHROME_BIN=chromium-browser - export DISPLAY=:99.0 - sh -e /etc/init.d/xvfb start 5 提交到远程仓库上 123git add . git commit -m &apos;add travis ci&apos;git push origin master 6 此时可以在travis上查看测试反馈 有关travis的配置文档：https://docs.travis-ci.com/user/languages/javascript-with-nodejs/ 参考文档：https://nodejs.org/api/assert.htmlhttps://github.com/shouldjs/should.jshttps://github.com/Automattic/expect.jshttps://www.chaijs.comhttps://mochajs.orghttps://jasmine.github.iohttp://karma-runner.github.iohttps://docs.travis-ci.com/user/languages/javascript-with-nodejs]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于nodejs的雪碧图制作工具]]></title>
    <url>%2Fblog%2F20181103%2Fd968dc4.html</url>
    <content type="text"><![CDATA[雪碧图（CSS sprite ），就是把很多小图标合并为一张图片。在Web开发中，使用雪碧图是优化Web性能的一种方法。 雪碧图的原理就是将页面中使用到的小图标合成为一张总图。这样的话当我们想要使用雪碧图中的某一个小图标，应该通过如何实现呢？ 答案是通过css的background-position，background-position的默认坐标是（0，0），（这次主要讲雪碧图制作工具） 前颜（yan）雪碧图（CSS sprite ），就是把很多小图标合并为一张图片。 在Web开发中，使用雪碧图是优化Web性能的一种方法。 比如你可能遇到过这样的一种场景：在你的页面中，使用到了很多的小图标，然后你的每个小图标都是通过img src来引用的。比如：1&lt;img src='logo.png'&gt; 通过这种方式虽然比较方便，但是存在的一个缺点就是性能问题，即浏览器在解析每个小图标时，都要发起一次http或（https）请求，而这个小图标本身却很小，可能只有十几k甚至几k，那么为每个小图标单独发起http请求，其实有点资源浪费。 为什么会资源浪费呢？ 浏览器在与服务器进行http请求的过程中，需要有一个类似握手通信的过程，然后才是真正的获取数据。 举个例子，在这里我把浏览器发起的http图片请求简单分为两个过程，分别为： 1、浏览器与服务器的通信握手过程，假设耗时X ms（毫秒） 2、真正的数据获取过程，假设耗时 Y ms（毫秒） 那么浏览器发起一次http请求的总耗时为：sum(1)=X+Y ms，由于小图标数据很小，可能只有几k，因此通信过程的耗时X是大于Y的。 而当你在网页中引用了很多小图标时，假设有n个小图标，此时总耗时为sum(n)=nX+nY ms，通过对比sum(1)和sum(n)，你就会发现，上面所说的资源浪费主要是在于通信握手的时间Y。此时，我就会想，如果我一次性取得所有的小图标，那么总耗时就变成了sum(n)=nX+Y ms，这样就能节省(n-1)Y的http握手通信的时间开销，从而优化了web的响应性能。 一、雪碧图抠图（background-position）通过前面的介绍，我们知道，雪碧图的原理就是将页面中使用到的小图标合成为一张总图。这样的话当我们想要使用雪碧图中的某一个小图标，应该通过如何实现呢？ 答案是通过css的background-position，background-position的默认坐标是（0，0），关于background-position的详细使用，大家可以网上搜索一下，资料很多。（这次主要讲雪碧图制作工具） 二、雪碧图制作工具 simple-sprite那么如何合成雪碧图呢？怎样才能更方便的合成雪碧图呢？ 因为懒，我的想法是，每次当我需要合成雪碧图时，我只要经过以下尽量简单的步骤就可以快速合成，并且可以导出各个小图标在雪碧图中的background-position css样式。为此，我用nodejs写了一个雪碧图制作工具：simple-sprite，并打包生成npm包发布至npm官网。 雪碧图制作步骤如下： 1 创建雪碧图生成工程 12mkdir sprite-generatorcd sprite-generator 2 初始化工程1npm init 3 把所有小图标放到imgs中1mkdir imgs &amp;&amp; 把所有的小图标放到imgs中 4 下载 simple-sprite npm包1npm install --save simple-sprite 5 运行生成雪碧图123let sprite = require('simple-sprite');sprite.generateSprite('./imgs'); simple-sprite：https://www.npmjs.com/package/simple-sprite 三、github源码构建工具：rollup github源码：https://github.com/SimpleCodeCX/simple-sprite#readme （如果你点开了我的github源码连接，顺便也帮我点个star哦！哈哈）]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Diffie-Hellman密钥协商算法]]></title>
    <url>%2Fblog%2F20180923%2F4db4f43.html</url>
    <content type="text"><![CDATA[严格来说，DH算法其实并不是一种加密算法，因为它本身并不是用于加密的，我的理解是用于双方协商计算，即双方按照某种合约进行计算，从而计算出一种相同的结果。 加密算法介绍目前常用的加密算法主要有：哈希算法（比如MD5、SHA族、Hmac），对称加密算法（比如AES），非对称加密算法（RSA），以及Diffie-Hellman密钥协商算法等等，这几种算法都有各自的特点，适合的场景也不一样，这里只做简单的介绍，想详细了解的话，网上资料很多，可以自行查看相关的资料。 各类算法的特点： 哈希算法：正向快速，不可逆性，即加密后是很难解密出明文的。经常用于数据加密和数据校验。 对称加密算法：AES是一种常用的对称加密算法，其特点是加解密都用同一个密钥。 非对称加密算法RSA：RSA算法是一种非对称加密算法，由一个私钥和一个公钥构成的密钥对，通过私钥加密，公钥解密，或者通过公钥加密，私钥解密。其中，公钥可以公开，私钥必须保密。 Diffie-Hellman密钥协商算法：Diffie-Hellman是一种密钥协商算法（简称DH算法），DH算法基于一种数学原理，能够在双方不泄露密钥的情况下协商出一种密钥来。 场景描述在客户端向服务器端发送数据的过程中，如果是比较重要的数据（比如密码，敏感数据等），一般需要先在客户端进行加密后再发送，服务器接收到数据后再进行解密得到原始数据。(反过来服务器返回数据给客户端也是一样的道理) 这里假设客户端和服务器端采用AES（对称加密算法）进行加解密传输的数据，AES加密算法有一个特点就是加解密都用同一个密钥（这里把该密钥称作secretKey），所以双方都通过secretKey进行数据加解密。 因此在客户端向服务器第一次传输数据的时候，客户端需要先向服务器端获取secretKey，并且保存在客户端，而这种直接向服务器获取明文secretKey的过程是很容易被第三者拦截的，也就是说这一过程是不安全的。（哈哈，除非是服务器把secretKey写到纸上，亲手偷偷地递给客户端） 因此呢，客户端向服务器获取secretKey的这一过程，也是需要进行加密的。 那么，服务器需要怎么做才能把secretKey安全的送达客户端呢？ 目前常采用的方法有：RSA 或 Diffie-Hellman 通过RSA安全传输密钥RSA有一个公钥和一个私钥，公钥是允许公开出去的，私钥是保留的。RSA的要点在于用公钥加密的数据需要用私钥解密，用私钥加密的数据，需要用公钥解密。因此，比如这时候客户端把公钥发送给服务器，服务器利用客户端的公钥对secretKey进行加密，那么这份加密后的secretKey数据，就只有客户端的私钥能解开啦。即使第三者拿到了这份数据也解密不了，除非能获取到客户端的私钥。 所以，通过RSA的方式，服务器就能把secretKey安全的传递到客户端的手里啦。（不过，RSA也是有安全漏洞的，被称作中间人攻击，由于篇幅原因，这里就先不讲啦！大家自行百度。） 虽然使用RSA能够安全的传输secretKey密钥，但是麻烦点在于需要生成一对公钥和私钥，并且把公钥发送给对方，而且加解密速度比较慢。所以，介绍第二种：Diffie-Hellman密钥协商算法。 通过DH算法协商密钥严格来说，DH算法其实并不是一种加密算法，因为它本身并不是用于加密的，我的理解是用于双方协商计算，即双方按照某种合约进行计算，从而计算出一种相同的结果。 原理如下： 第一步：初始化 &nbsp;&nbsp;&nbsp;&nbsp;比如现在服务器提供了两个随机公钥数字（允许公开）：pubN=10，modN=3; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端自己生成了一个随机私钥数字（不可公开，服务器也不知道）：cPrivN=2; 服务器端也自己生成了一个随机私钥数字（不可公开，客户端也不知道）：sPrivN=4; 第二步：客户端、服务器端分别基于相同的数学公式进行计算，计算结果称作公钥结果：pubResult 客户端进行数学计算：cPubResult = pubN cPrivN % modN = 10 2 % 3 = 2；（计算结果允许公开） 服务器进行数学计算：sPubResult = pubN sPrivN % modN = 10 4 % 3 = 1；（计算结果允许公开） 客户端和服务器端交换公钥结果，客户端得到sPubResult=1，服务器端得到cPubResult=2。 第三步：协商出一致的密钥数字:keyN（客户端和服务器端得出的结果是一致的） 客户端：cKeyN = sPubResult cPrivN % modN= 1 2 % 3 = 2；服务器：sKeyN = cPubResult sPrivN % modN= 2 4 % 3 = 2； 到目前为止呢，双方都协商出了密钥，并且是一致的，但是呢，有没有见过密钥是number类型的？想必都没有吧，所以需要进行第四步，生成更长的密钥。 第四步：对密钥数字进行hash生成密钥串 123const hash = crypto.createHash('sha256');hash.update(this.keyN.toString());this.secretKey = hash.digest('hex');]]></content>
      <categories>
        <category>加密算法</category>
      </categories>
      <tags>
        <tag>加密算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于ionic4、cordova搭建android开发环境]]></title>
    <url>%2Fblog%2F20180827%2Fa09cfe7a.html</url>
    <content type="text"><![CDATA[最近公司有一个项目需求是利用h5进行跨平台开发，这里所说的跨平台开发指的是：将h5代码利用某种方式或工具环境进行打包，最后生成android的apk以及ios的ipa。 前颜（yan）最近公司有一个项目需求是利用h5进行跨平台开发，这里所说的跨平台开发指的是：将h5代码利用某种方式或工具环境进行打包，最后生成android的apk以及ios的ipa。本文只讲解android开发环境，等以后有空了再介绍一篇关于ios的。 一、知识讲解本文基于ionic4+cordova构建android应用，首先做一下以下的知识梳理。 1 ionic是一套用于开发混合手机应用的开源h5框架，包含一套适合于mobile application的ui组件库以及相关访问原生设备的native接口等。目前ionic已更新至ionic4，ionic4的特色在于兼容angular6以及rxjs6，有着angular6的特点，因此，angular的开发者可以很容易的切换到ionic4的开发。ionic官方文档：https://beta.ionicframework.com/docs/intro 2 cordova是一套开源的移动应用开发框架。cordova能够利用web应用（如ionic构建的h5应用）构建android工程以及ios工程（今天只讲android工程）。并且可以编译android工程，最后生成android apk。cordova官方文档：https://cordova.apache.org/docs/en/latest/guide/overview/index.html 3 android sdkcordova在编译android工程的时候需要有android sdk等开发环境的支持。如果想对ionic和cordova更加详细的了解，请见官方文档。 接下来，开始搭建开发环境。因此，综上所述，需要搭建的开发环境有：ionic、cordova以及android 开发环境。 我的开发环境如下（仅供参考）：node：v8.11.1npm：5.5.1ionic：4.0.3cordova：8.0.0jdk：1.8.0_45gradle：4.9 二、安装nodejs首先你都懂的，要装个node环境，因为Ionic和cordova的安装以及后续的许多前端工具的安装都依赖于node的包管理器npm。建议安装最新版本的node。没有装过的请看安装教程：http://www.runoob.com/nodejs/nodejs-install-setup.html 三、安装ionic1 安装全局的ionic cli：1npm install -g ionic 2 检测ionic是否安装成功：1ionic -v 3 创建ionic项目安装成功后，即可通过ionic cli命令创建ionic项目：1ionic start myApp tabs --type=angular （注意：目前ionic4是beta版，需要加上 –type=angular才能创建基于angular的项目，后面等发布正式版本，估计就不需要了） 说明：上面命令中tabs是ionic的其中一个模板，可以通过 ionic start --list 查看可选的模板。比如： ionic start myApp blank --type=angular 可以创建空白模板的ionic项目 4 下载ionic项目的node_modules包 在第三步创建ionic项目的过程中，ionic cli会自动帮你下载依赖的node_modules包（可以通过package.json查看项目所依赖的包），如果下载失败的话，可以删除node_modules文件夹，手动安装：npm install 5 运行ionic项目： ionic serveionic项目本身就是一个web h5项目，因此可以像vue、angular一样运行于浏览器。好了，ionic项目搭建成功后，接下来搭建cordova环境，然后利用cordova把ionic项目构建android工程。 四、安装cordova1 安装全局的cordova：npm install -g cordova 2 检测cordova是否安装成功：cordova -v 3 构建android工程1） 查看支持的平台以及版本：ionic cordova platform ls2） 构建android platform：ionic cordova platform add android 说明：此步骤会修改ionic的目录结构，让ionic支持cordova。构建成功后，会在platforms目录下生成一个android工程。 其他cordova命令：移除android工程：ionic cordova platform remove android添加指定版本的android工程：ionic cordova platform add android@6.0.0 至此，cordova环境已经搭建完成，并且利用ionic生成了一个android工程（位于/platforms/android）。但是此时还不能通过cordova编译该android工程，因为cordova编译android工程需要有android sdk的开发环境。所以，接下来配置android sdk环境。 五、配置android sdk环境1 安装jdk（下载、解压、配置环境变量）安装jdk可以参考这篇文章的jdk章节：https://blog.csdn.net/love4399/article/details/77164500用cmd 运行 javac -version 检查是否安装成功 2 安装android-sdk（下载、解压、配置环境变量）安装android-sdk可以参考这篇文章的android-sdk章节：https://blog.csdn.net/love4399/article/details/77164500用cmd 运行 adb –version 检查是否安装成功 3 安装gradle（下载、解压、配置环境变量）安装安装gradle可以参考这篇文章：https://jingyan.baidu.com/article/00a07f38706f0b82d028dcf3.html用cmd 运行 gradle -v 检查是否安装成功 以上环境搭建成功之后，即可通过cordova命令进行编译：ionic cordova build android，编译成功之后，会在/myApp/platforms/android/app/build/outputs/apk/debug目录下生成一个 xxx.apk。 六、构建第一个android应用至此，一个android apk就生成啦。最后总结一下利用ionic4+cordova构建android应用的过程：1 ionic start myApp blank–type=angular （创建ionic项目）2 ionic cordova platform add android （添加android平台）3 ionic cordova build android （编译生成apk）是不是很简单，前提是以上环境都已经搭建好了。 参考文档：1）cordova：https://baike.baidu.com/item/Cordova/9192368?fr=aladdin2）ionic：https://baike.baidu.com/item/ionic/1326386?fr=aladdin3）ionic开发android app步骤4）2017年Android SDK下载安装及配置教程：https://blog.csdn.net/love4399/article/details/77164500]]></content>
      <categories>
        <category>hybrid</category>
      </categories>
      <tags>
        <tag>hybrid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa2实现文件上传]]></title>
    <url>%2Fblog%2F20180722%2Fkoa2_file_upload.html</url>
    <content type="text"><![CDATA[koa2实现文件上传 知识讲解koa2框架是一个基于中间件的框架，也就是说，需要使用到的功能，比如路由（koa-router），日志（koa-logger），都可以找到相应的中间件库，即npm包，然后通过app.use(…)引进来。本文的主题：实现文件上传就是通过引用相应的中间来实现的。我查了一下资料，发现可以实现文件上传的中间件有3个，选择其中一个就可以了：1）koa-body2）busboy3）koa-multer关于以上三种中间件的差异可以自行网上查资料，这里我选择比较顺眼的koa-body，实用简单。 代码实现步骤一：下载koa-body npm包1npm install koa-body --save 步骤二：在koa项目中引用koa-body中间件1234567const koaBody = require('koa-body');app.use(koaBody(&#123; multipart: true, formidable: &#123; maxFileSize: 200*1024*1024 // 设置上传文件大小最大限制，默认2M &#125;&#125;)); 步骤三：使用koa-body中间件后，即可通过ctx.request.files获取上传的文件提醒： 新版本的koa-body通过ctx.request.files获取上传的文件 旧版本的koa-body通过ctx.request.body.files获取上传的文件 朋友们千万不要入坑哈，本人就入坑过半天。 步骤四：获取到文件之后，通过fs将文件保存到服务器的指定目录上传单个文件：123456789101112router.post('/uploadfile', async (ctx, next) =&gt; &#123; // 上传单个文件 const file = ctx.request.files.file; // 获取上传文件 // 创建可读流 const reader = fs.createReadStream(file.path); let filePath = path.join(__dirname, 'public/upload/') + `/$&#123;file.name&#125;`; // 创建可写流 const upStream = fs.createWriteStream(filePath); // 可读流通过管道写入可写流 reader.pipe(upStream); return ctx.body = "上传成功！";&#125;); 上传多个文件:123456789101112131415router.post('/uploadfiles', async (ctx, next) =&gt; &#123; // 上传多个文件 const files = ctx.request.files.file; // 获取上传文件 for (let file of files) &#123; // 创建可读流 const reader = fs.createReadStream(file.path); // 获取上传文件扩展名 let filePath = path.join(__dirname, 'public/upload/') + `/$&#123;file.name&#125;`; // 创建可写流 const upStream = fs.createWriteStream(filePath); // 可读流通过管道写入可写流 reader.pipe(upStream); &#125; return ctx.body = "上传成功！";&#125;); 前端代码顺便把前端的代码也附上，前端通过提交表单，把文件发送到你的服务器 1234&lt;form action="http://localhost:8080/api/upload" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="file" id="file" value="" multiple="multiple" /&gt; &lt;input type="submit" value="提交"/&gt;&lt;/form&gt; 最后总结今天在项目中实现文件上传的时候，也一不小心入了一下坑，为什么呢？（请看以上步骤三）在网上找的大部分资料都是通过ctx.request.body.files来获取上传的文件，这个是旧版本的koa-body的获取文件方法，为了安全考虑，新版本的koa-body采用ctx.request.files来获取文件。总结原因，以后要学会找官方文档，以官方文档为主，其他文档为辅，这样才对。]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
</search>
