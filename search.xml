<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基于nodejs的雪碧图制作工具]]></title>
    <url>%2Fblog%2F20181103%2Fd968dc4.html</url>
    <content type="text"><![CDATA[前颜（yan）雪碧图（CSS sprite ），就是把很多小图标合并为一张图片。 在Web开发中，使用雪碧图是优化Web性能的一种方法。 比如你可能遇到过这样的一种场景：在你的页面中，使用到了很多的小图标，然后你的每个小图标都是通过img src来引用的。比如：1&lt;img src='logo.png'&gt; 通过这种方式虽然比较方便，但是存在的一个缺点就是性能问题，即浏览器在解析每个小图标时，都要发起一次http或（https）请求，而这个小图标本身却很小，可能只有十几k甚至几k，那么为每个小图标单独发起http请求，其实有点资源浪费。 为什么会资源浪费呢？ 浏览器在与服务器进行http请求的过程中，需要有一个类似握手通信的过程，然后才是真正的获取数据。 举个例子，在这里我把浏览器发起的http图片请求简单分为两个过程，分别为： 1、浏览器与服务器的通信握手过程，假设耗时X ms（毫秒） 2、真正的数据获取过程，假设耗时 Y ms（毫秒） 那么浏览器发起一次http请求的总耗时为：sum(1)=X+Y ms，由于小图标数据很小，可能只有几k，因此通信过程的耗时X是大于Y的。 而当你在网页中引用了很多小图标时，假设有n个小图标，此时总耗时为sum(n)=nX+nY ms，通过对比sum(1)和sum(n)，你就会发现，上面所说的资源浪费主要是在于通信握手的时间Y。此时，我就会想，如果我一次性取得所有的小图标，那么总耗时就变成了sum(n)=nX+Y ms，这样就能节省(n-1)Y的http握手通信的时间开销，从而优化了web的响应性能。 一、雪碧图抠图（background-position）通过前面的介绍，我们知道，雪碧图的原理就是将页面中使用到的小图标合成为一张总图。这样的话当我们想要使用雪碧图中的某一个小图标，应该通过如何实现呢？ 答案是通过css的background-position，background-position的默认坐标是（0，0），关于background-position的详细使用，大家可以网上搜索一下，资料很多。（这次主要讲雪碧图制作工具） 二、雪碧图制作工具 simple-sprite那么如何合成雪碧图呢？怎样才能更方便的合成雪碧图呢？ 因为懒，我的想法是，每次当我需要合成雪碧图时，我只要经过以下尽量简单的步骤就可以快速合成，并且可以导出各个小图标在雪碧图中的background-position css样式。为此，我用nodejs写了一个雪碧图制作工具：simple-sprite，并打包生成npm包发布至npm官网。 雪碧图制作步骤如下： 1 创建雪碧图生成工程 12mkdir sprite-generatorcd sprite-generator 2 初始化工程1npm init 3 把所有小图标放到imgs中1mkdir imgs &amp;&amp; 把所有的小图标放到imgs中 4 下载 simple-sprite npm包1npm install --save simple-sprite 5 运行生成雪碧图123let sprite = require('simple-sprite');sprite.generateSprite('./imgs'); simple-sprite：https://www.npmjs.com/package/simple-sprite 三、github源码构建工具：rollup github源码：https://github.com/SimpleCodeCX/simple-sprite#readme （如果你点开了我的github源码连接，顺便也帮我点个star哦！哈哈）]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Diffie-Hellman密钥协商算法]]></title>
    <url>%2Fblog%2F20180923%2F4db4f43.html</url>
    <content type="text"><![CDATA[加密算法介绍目前常用的加密算法主要有：哈希算法（比如MD5、SHA族、Hmac），对称加密算法（比如AES），非对称加密算法（RSA），以及Diffie-Hellman密钥协商算法等等，这几种算法都有各自的特点，适合的场景也不一样，这里只做简单的介绍，想详细了解的话，网上资料很多，可以自行查看相关的资料。 各类算法的特点： 哈希算法：正向快速，不可逆性，即加密后是很难解密出明文的。经常用于数据加密和数据校验。 对称加密算法：AES是一种常用的对称加密算法，其特点是加解密都用同一个密钥。 非对称加密算法RSA：RSA算法是一种非对称加密算法，由一个私钥和一个公钥构成的密钥对，通过私钥加密，公钥解密，或者通过公钥加密，私钥解密。其中，公钥可以公开，私钥必须保密。 Diffie-Hellman密钥协商算法：Diffie-Hellman是一种密钥协商算法（简称DH算法），DH算法基于一种数学原理，能够在双方不泄露密钥的情况下协商出一种密钥来。 场景描述在客户端向服务器端发送数据的过程中，如果是比较重要的数据（比如密码，敏感数据等），一般需要先在客户端进行加密后再发送，服务器接收到数据后再进行解密得到原始数据。(反过来服务器返回数据给客户端也是一样的道理) 这里假设客户端和服务器端采用AES（对称加密算法）进行加解密传输的数据，AES加密算法有一个特点就是加解密都用同一个密钥（这里把该密钥称作secretKey），所以双方都通过secretKey进行数据加解密。 因此在客户端向服务器第一次传输数据的时候，客户端需要先向服务器端获取secretKey，并且保存在客户端，而这种直接向服务器获取明文secretKey的过程是很容易被第三者拦截的，也就是说这一过程是不安全的。（哈哈，除非是服务器把secretKey写到纸上，亲手偷偷地递给客户端） 因此呢，客户端向服务器获取secretKey的这一过程，也是需要进行加密的。 那么，服务器需要怎么做才能把secretKey安全的送达客户端呢？ 目前常采用的方法有：RSA 或 Diffie-Hellman 通过RSA安全传输密钥RSA有一个公钥和一个私钥，公钥是允许公开出去的，私钥是保留的。RSA的要点在于用公钥加密的数据需要用私钥解密，用私钥加密的数据，需要用公钥解密。因此，比如这时候客户端把公钥发送给服务器，服务器利用客户端的公钥对secretKey进行加密，那么这份加密后的secretKey数据，就只有客户端的私钥能解开啦。即使第三者拿到了这份数据也解密不了，除非能获取到客户端的私钥。 所以，通过RSA的方式，服务器就能把secretKey安全的传递到客户端的手里啦。（不过，RSA也是有安全漏洞的，被称作中间人攻击，由于篇幅原因，这里就先不讲啦！大家自行百度。） 虽然使用RSA能够安全的传输secretKey密钥，但是麻烦点在于需要生成一对公钥和私钥，并且把公钥发送给对方，而且加解密速度比较慢。所以，介绍第二种：Diffie-Hellman密钥协商算法。 通过DH算法协商密钥严格来说，DH算法其实并不是一种加密算法，因为它本身并不是用于加密的，我的理解是用于双方协商计算，即双方按照某种合约进行计算，从而计算出一种相同的结果。 原理如下： 第一步：初始化 &nbsp;&nbsp;&nbsp;&nbsp;比如现在服务器提供了两个随机公钥数字（允许公开）：pubN=10，modN=3; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端自己生成了一个随机私钥数字（不可公开，服务器也不知道）：cPrivN=2; 服务器端也自己生成了一个随机私钥数字（不可公开，客户端也不知道）：sPrivN=4; 第二步：客户端、服务器端分别基于相同的数学公式进行计算，计算结果称作公钥结果：pubResult 客户端进行数学计算：cPubResult = pubN cPrivN % modN = 10 2 % 3 = 2；（计算结果允许公开） 服务器进行数学计算：sPubResult = pubN sPrivN % modN = 10 4 % 3 = 1；（计算结果允许公开） 客户端和服务器端交换公钥结果，客户端得到sPubResult=1，服务器端得到cPubResult=2。 第三步：协商出一致的密钥数字:keyN（客户端和服务器端得出的结果是一致的） 客户端：cKeyN = sPubResult cPrivN % modN= 1 2 % 3 = 2；服务器：sKeyN = cPubResult sPrivN % modN= 2 4 % 3 = 2； 到目前为止呢，双方都协商出了密钥，并且是一致的，但是呢，有没有见过密钥是number类型的？想必都没有吧，所以需要进行第四步，生成更长的密钥。 第四步：对密钥数字进行hash生成密钥串 123const hash = crypto.createHash('sha256');hash.update(this.keyN.toString());this.secretKey = hash.digest('hex');]]></content>
  </entry>
  <entry>
    <title><![CDATA[基于ionic4、cordova搭建android开发环境]]></title>
    <url>%2Fblog%2F20180827%2Fa09cfe7a.html</url>
    <content type="text"><![CDATA[前颜（yan）最近公司有一个项目需求是利用h5进行跨平台开发，这里所说的跨平台开发指的是：将h5代码利用某种方式或工具环境进行打包，最后生成android的apk以及ios的ipa。本文只讲解android开发环境，等以后有空了再介绍一篇关于ios的。 一、知识讲解本文基于ionic4+cordova构建android应用，首先做一下以下的知识梳理。 1 ionic是一套用于开发混合手机应用的开源h5框架，包含一套适合于mobile application的ui组件库以及相关访问原生设备的native接口等。目前ionic已更新至ionic4，ionic4的特色在于兼容angular6以及rxjs6，有着angular6的特点，因此，angular的开发者可以很容易的切换到ionic4的开发。ionic官方文档：https://beta.ionicframework.com/docs/intro 2 cordova是一套开源的移动应用开发框架。cordova能够利用web应用（如ionic构建的h5应用）构建android工程以及ios工程（今天只讲android工程）。并且可以编译android工程，最后生成android apk。cordova官方文档：https://cordova.apache.org/docs/en/latest/guide/overview/index.html 3 android sdkcordova在编译android工程的时候需要有android sdk等开发环境的支持。如果想对ionic和cordova更加详细的了解，请见官方文档。 接下来，开始搭建开发环境。因此，综上所述，需要搭建的开发环境有：ionic、cordova以及android 开发环境。 我的开发环境如下（仅供参考）：node：v8.11.1npm：5.5.1ionic：4.0.3cordova：8.0.0jdk：1.8.0_45gradle：4.9 二、安装nodejs首先你都懂的，要装个node环境，因为Ionic和cordova的安装以及后续的许多前端工具的安装都依赖于node的包管理器npm。建议安装最新版本的node。没有装过的请看安装教程：http://www.runoob.com/nodejs/nodejs-install-setup.html 三、安装ionic1 安装全局的ionic cli：1npm install -g ionic 2 检测ionic是否安装成功：1ionic -v 3 创建ionic项目安装成功后，即可通过ionic cli命令创建ionic项目：1ionic start myApp tabs --type=angular （注意：目前ionic4是beta版，需要加上 –type=angular才能创建基于angular的项目，后面等发布正式版本，估计就不需要了） 说明：上面命令中tabs是ionic的其中一个模板，可以通过 ionic start --list 查看可选的模板。比如： ionic start myApp blank --type=angular 可以创建空白模板的ionic项目 4 下载ionic项目的node_modules包 在第三步创建ionic项目的过程中，ionic cli会自动帮你下载依赖的node_modules包（可以通过package.json查看项目所依赖的包），如果下载失败的话，可以删除node_modules文件夹，手动安装：npm install 5 运行ionic项目： ionic serveionic项目本身就是一个web h5项目，因此可以像vue、angular一样运行于浏览器。好了，ionic项目搭建成功后，接下来搭建cordova环境，然后利用cordova把ionic项目构建android工程。 四、安装cordova1 安装全局的cordova：npm install -g cordova 2 检测cordova是否安装成功：cordova -v 3 构建android工程1） 查看支持的平台以及版本：ionic cordova platform ls2） 构建android platform：ionic cordova platform add android 说明：此步骤会修改ionic的目录结构，让ionic支持cordova。构建成功后，会在platforms目录下生成一个android工程。 其他cordova命令：移除android工程：ionic cordova platform remove android添加指定版本的android工程：ionic cordova platform add android@6.0.0 至此，cordova环境已经搭建完成，并且利用ionic生成了一个android工程（位于/platforms/android）。但是此时还不能通过cordova编译该android工程，因为cordova编译android工程需要有android sdk的开发环境。所以，接下来配置android sdk环境。 五、配置android sdk环境1 安装jdk（下载、解压、配置环境变量）安装jdk可以参考这篇文章的jdk章节：https://blog.csdn.net/love4399/article/details/77164500用cmd 运行 javac -version 检查是否安装成功 2 安装android-sdk（下载、解压、配置环境变量）安装android-sdk可以参考这篇文章的android-sdk章节：https://blog.csdn.net/love4399/article/details/77164500用cmd 运行 adb –version 检查是否安装成功 3 安装gradle（下载、解压、配置环境变量）安装安装gradle可以参考这篇文章：https://jingyan.baidu.com/article/00a07f38706f0b82d028dcf3.html用cmd 运行 gradle -v 检查是否安装成功 以上环境搭建成功之后，即可通过cordova命令进行编译：ionic cordova build android，编译成功之后，会在/myApp/platforms/android/app/build/outputs/apk/debug目录下生成一个 xxx.apk。 六、构建第一个android应用至此，一个android apk就生成啦。最后总结一下利用ionic4+cordova构建android应用的过程：1 ionic start myApp blank–type=angular （创建ionic项目）2 ionic cordova platform add android （添加android平台）3 ionic cordova build android （编译生成apk）是不是很简单，前提是以上环境都已经搭建好了。 参考文档：1）cordova：https://baike.baidu.com/item/Cordova/9192368?fr=aladdin2）ionic：https://baike.baidu.com/item/ionic/1326386?fr=aladdin3）ionic开发android app步骤4）2017年Android SDK下载安装及配置教程：https://blog.csdn.net/love4399/article/details/77164500]]></content>
  </entry>
</search>
