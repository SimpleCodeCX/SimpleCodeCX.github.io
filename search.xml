<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基于nodejs的雪碧图制作工具]]></title>
    <url>%2Fblog%2F20181103%2Fd968dc4.html</url>
    <content type="text"><![CDATA[前颜（yan）雪碧图（CSS sprite ），就是把很多小图标合并为一张图片。 在Web开发中，使用雪碧图是优化Web性能的一种方法。 比如你可能遇到过这样的一种场景：在你的页面中，使用到了很多的小图标，然后你的每个小图标都是通过img src来引用的。1&lt;img src='logo.png'&gt; 通过这种方式虽然比较方便，但是存在的一个缺点就是性能问题，即浏览器在解析每个小图标时，都要发起一次http或（https）请求，而这个小图标本身却很小，可能只有十几k甚至几k，那么为每个小图标单独发起http请求，其实有点资源浪费。 为什么会资源浪费呢？ 浏览器在与服务器进行http请求的过程中，需要有一个类似握手通信的过程，然后才是真正的获取数据。 举个例子，在这里我把浏览器发起的http图片请求简单分为两个过程，分别为： 1、浏览器与服务器的通信握手过程，假设耗时X ms（毫秒） 2、真正的数据获取过程，假设耗时 Y ms（毫秒） 那么浏览器发起一次http请求的总耗时为：sum(1)=X+Y ms，由于小图标数据很小，可能只有几k，因此通信过程的耗时X是大于Y的。 而当你在网页中引用了很多小图标时，假设有n个小图标，此时总耗时为sum(n)=nX+nY ms，通过对比sum(1)和sum(n)，你就会发现，上面所说的资源浪费主要是在于通信握手的时间Y。此时，我就会想，如果我一次性取得所有的小图标，那么总耗时就变成了sum(n)=nX+Y ms，这样就能节省(n-1)Y的http握手通信的时间开销，从而优化了web的响应性能。 一、雪碧图抠图（background-position）通过前面的介绍，我们知道，雪碧图的原理就是将页面中使用到的小图标合成为一张总图。这样的话当我们想要使用雪碧图中的某一个小图标，应该通过如何实现呢？ 答案是通过css的background-position，background-position的默认坐标是（0，0），关于background-position的详细使用，大家可以网上搜索一下，资料很多。（这次主要讲雪碧图制作工具） 二、雪碧图制作工具 simple-sprite那么如何合成雪碧图呢？怎样才能更方便的合成雪碧图呢？ 因为懒，我的想法是，每次当我需要合成雪碧图时，我只要经过以下尽量简单的步骤就可以快速合成，并且可以导出各个小图标在雪碧图中的background-position css样式。为此，我用nodejs写了一个雪碧图制作工具：simple-sprite，并打包生成npm包发布至npm官网。 雪碧图制作步骤如下： 1 创建雪碧图生成工程 12mkdir sprite-generatorcd sprite-generator 2 初始化工程1npm init 3 把所有小图标放到imgs中1mkdir imgs &amp;&amp; 把所有的小图标放到imgs中 4 下载 simple-sprite npm包1npm install --save simple-sprite 5 运行生成雪碧图123let sprite = require('simple-sprite');sprite.generateSprite('./imgs'); simple-sprite：https://www.npmjs.com/package/simple-sprite 三、github源码构建工具：rollup github源码：https://github.com/SimpleCodeCX/simple-sprite#readme （如果你点开了我的github源码连接，顺便也帮我点个star哦！哈哈）]]></content>
  </entry>
</search>
